https://www.youtube.com/live/kRJ4Xx4jEBk
https://www.youtube.com/live/dLt0ktv6Ca0
[[Олифер 27. Аутентификация, авторизация, управление доступом.]]
# Аутентификация часть 1
- пароль;
- OTP - one time password (используется как при однофакторной, так и при двухфакторной аутентификации, при варианте - что-то чем владею, например когда приходит смска на телефон). Для пользователей проблема, что необходимо запомнить кучу паролей на разных сайтах, поэтому производители хотят упростить достп;
- Токен - уникальная строка, которая как правило выдается после аутентификации и сохраняется в кэше. Дальше все запросы от пользователя идут с этим кэшем;
- сертификат - выписывается сотруднику, устанавливается на машине и далее сотрудник имеет доступ;
- биометрия - метро;
## Как хранить пароль в БД
### Ранее
1. Пароли хранились в открытом виде.
Нельзя хранить пароль в открытом виде, т.к. у сотрудников-администраторов будет иметься доступ.
2. Раньше пароли хранили в виде хэш-функции, представляющие собой какую-то строку, однако пользователи с одинаковыми паролями будут иметь одинаковый хэш. Но также можно перебирать пароли методом перебора или по словарю.
### Сейчас
1. Хэш с уникальной солью - уникальная строка определенной длины + пароль и отсюда берётся хэш-функция.
	1. Соль - уникальная генерируемая строка складываемая с паролем.
2. Стойкие к перебору алгоритмы - PBKDF2, BCrypt, Argon2. В этих случаях вычисления хэша происходит медленно.
![[Pasted image 20250119092346.png]]
Зеленое - алгоритм по которому была получена соль и хэш для дальнейшего декодирования.

Даже если украдут Базу данных, то для того, чтобы получить пароль необходимо будет разобраться с хэш-функцией.
Прочитает пользователь хэш, прочитает пользователь соль, все это дело ему придется перебирать по словарю, чтобы получить доступ. Также могут использоваться специальные замедляющие алгоритмы.
## PAKE
PAKE - password authenticated key agreement.
Исключает факт передачи пароль на сервер в открытом виде.
Используется чтобы исключить атаку посередине, во время передачи пароля на сервер.
### Доказательство с нулевым разглашением
![[Pasted image 20250119093334.png]]
Цель - удостовериться, что пользователь знает пароль
Алгоритм:
В замкнутой пещере, где два входа А и Б между которыми стоит кодовая дверь, заходит девушкаи подбрасывает монетку. Ей выпадает Б сторона и она идёт до двери с кодовым замком. Парень в это время ждет снаружи и не знает куда она зашла.
После того как девушка дошла до двери, заходит парень, подбрасывает монетку и кричит девушке из какого входа она должна вернуться. Если девушка должна вернуться из входа А, она набирает пароль и возвращается. Если из Б, она не набирает пароль и просто возвращается, ей повезло.
Однако если ей необходимо будет 20 раз провести эту операцию, то вероятность того, что ей повезет 20 раз и не надо будет вводить пароль - 1 к миллиону.

#### Реализация на основе протокола
![[Pasted image 20250119094351.png]]
Авторизация в 2 этапа:
- первый шаг - Challenge;
- второй шаг - Verify;
## Многофакторная аутентификация
HOTP - hmac based one-time password algoritm. Основан на счетчике.
TOTP - time based  one-time password algoritm. Основан на первом варианте, основан на времени.
Особо не вникал в объяснение, многоступенчатый алгоритм.
## Пароль
![[Pasted image 20250119091542.png]]
# Авторизация
Рассматривается на основе микросервисной архитектуры.
![[Pasted image 20250119101228.png]]


![[Pasted image 20250119101436.png]]
После успешной аутентификации создается сессия, которая хранится в сессионом хранилище, и выдаем пользователю SessionId которое выдаем пользователю и оно хранится в браузере в виде куки.
Приложение APP1 получив запрос действие на какой-то запрос должен авторизовать этот запрос. Оно отправляет запрос на сервис авторизации проверяя что такая сессия существует и пользователю можно осуществлять эти действия.
Вопрос заключается в том, что нагрузка на сервис авторизации начинает увеличиваться.
## JWT - JSON Web Tokens
Чтобы снизить нагрузку на сервис авторизации используют Json веб токены.
Токен состоящий из трех частей. Основная идея токена, что данные внутри токена нельзя менять, если данные поменяются, то значит нарушена целостность токена и подпись не соответствует телу и заголовку, когда это вскрывается, токен уходит в бан.
Все это позволяет использовать токен в качестве доступа для других сервисов.
Таким образом пропадает необходимость каждый раз проверять ключи. Увеличивается производительность и пропадает необходимость в сессионом хранилище.
![[Pasted image 20250119101735.png]]
Заголовок - алгоритм, который будет использоваться для подписи нашего токена, тип токена, и Kid - ключ при помощи которого формируется подпись токена.
Тело токена - также свойства необходимые для нормальной авторизации.
Подпись токена - хэш от секретного ключа и от содержимого заголовка.

В случае если токен стал скомпроментирован, то токен необходимо отозвать.

# Аутентификация и авторизация в сторонних приложениях
Ситуация, когда заходишь на сайт через другую учетку. Например через гугл.
![[Pasted image 20250119221316.png]]
Медиуму мы не отдаем свои данные. При нажатии на логин в фэйсбук мы:
- по ссылке  переходим и логинимся в фэйсбук;
- проверяем ClientID, Scope, RedirectUri;
- после того аутентификация пройдена, фейсбук заявляет, что мы разрешаем медиуму получать данные, фейсбук генерирует код, и по redirectUri перенаправляет пользователя на сайт медиум и прицепляет AuthCode;
- также там имеется встроенная защита от фишинга, но её принцип я не понял, возможно через сертификаты;
- получив данные от фейсбука медиум уже использует свои данные в качестве клиента и взаимодействует с сервером фейсбука;
- фейсбук повторно запрашивает данные, медиум повторно их отправляет;
- фейсбук выписывает access token, и благодаря ему пользователь на медиуме получает определенные права исходя из доступа токена;


# Аутентификация часть 2
https://www.youtube.com/live/dLt0ktv6Ca0