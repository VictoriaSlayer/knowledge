# Вводная
[Основа](https://www.youtube.com/live/dLt0ktv6Ca0)
[[Олифер 26. Информационная безопасность]] - что такое идентификация, аутентификация, авторизация
[[Протоколы и что с ними частично связано №2]] - про AD, Kerberos и KeyCloak в этом контексте

Для начала мы проводим идентификацию пользователя, чтобы понять как мы его можем аутентифицировать, чтобы потом понять какие права мы можем ему дать. 

401 ответ от сервера означает именно невозможность клиентского запроса из-за того, что не хватает учетных данных клиента.

# OAuth 2.0
OAuth 2.0 - протокол авторизации, предназначенный для организации доступа клиентских приложений к ресурсам или данным учетных записей, пользователя на другом сервисе.

В качестве клиентских приложений выступают  веб-сервисы, мобильные и десктопные приложения. В качестве сервисов - mail.ru, gitHub, BitBucket и т.д. Протокол используют разработчики сторонних приложений.

Приложение может получить доступ к определенным данным пользователя не запрашивая их напрямую у пользователя, а получая их у сервиса авторизации.
Access token - термин описанный в стандарте OAuth 2.0, создается автоматически и постоянно меняется.
API token - то, что пользователь генерирует сам руками, идентификатор токена с привилегиями, некий механизм связать 2 программы имея некие права. Пользователь уже должен быть аутентифицирован. Токены которые выдаются при интеграциях системами с которыми происходит интеграция.
Bearer token - access token который мы получаем.
## Роли в OAuth 2.0
*Владелец ресурса* - пользователь, который предоставляет стороннему приложению доступ к своим данным.

*Сервер ресурсов* - сервер, на котором размещены защищенные ресурсы. Он отвечает за прием и ответ на запросы на доступ к защищенным ресурсам с использованием токена доступа.
Как правило это какие-то API к которым мы пытаемся обратиться.

*Клиент* - стороннее приложение, которое запрашивает авторизацию у владельца ресурса. Когда владелец ресурса предоставляет доступ, клиент получает токен доступа, который можно использовать для запроса ресурсов в пределах предоставленной области.

*Сервер авторизации* - сервер авторизации выдает клиенту токены доступа после того, как владелец ресурса успешно авторизует запрос. Этот процесс включает два этапа - сначала клиенту выдается код авторизации который затем используется для запроса токена доступа по URL-адресу токена доступа предоставленному сервером авторизации.

## Workflow авторизации
![[Pasted image 20250419213546.png]]
1 - пользователь в клиентском приложении вызывает ссылку на аутентификацию и авторизацию
2 - клиентское приложение отправляет запрос серверу аутентификации чтобы пройти всю процедуру
3-5 - сервер авторизации возвращает клиенту страницу, на которой он должен ввести имя и пароль
6 - после ввода данных логина/пароля осуществляется запрос на сервер авторизации где формируется код авторизации (это не код доступа к ресурсу) и передается в клиентское приложение.
7 - клиентское приложение отправляет указанный код на авторизационный сервер
8 - авторизационный сервер возвращает автотокен клиентскому приложению
9 - с автотокеном клиентское приложение может обратиться на сервер ресурсов, запросить тот или иной ресурс
10 - сервер ресурсов без участия пользователя и клиентского приложения осуществляет запрос к серверу авторизации чтобы получить информацию относительно токена. Осуществляется верификация токена.
11 - если с токеном все в порядке, осуществляется выдача требуемого ресурса, сервером ресурса клиентскому приложению.

## Авторизация через соцсети
![[Pasted image 20250419215656.png]]
Иногда помимо access token выдают еще refresh token, т.к. access token имеет малое время жизни.

# JWT
JSON Web Token (JWT) — это открытый стандарт (RFC 7519) для создания токенов доступа, основанный на формате JSON. Как правило, используется для передачи данных для аутентификации в клиент-серверных приложениях.

jwt.io
Содержание access token
![[Pasted image 20250419220420.png]]
красное - тип токена, алгоритм шифрования
фиолетовое - полезные аутентификационные данных (можно указывать роль, можно указывать скоуп действия пользователя)
голубая - сигнатура токена, хэш токена

Токены доступа могут храниться в разных форматах, наиболее распространенный из которых JWT.
Формат гарантирует, что токен также может содержать некоторые зашифрованные данные, которые можно безопасно получить до истечения срока действия токена.
Поскольку access token часто недолговечны, должен быть способ создать новый токен, когда предыдущий больше недействителен или срок его действия истек.

*Refresh token* - используется для получения новых токенов доступа и часто имеет более длительный срок службы чем токены доступа. Однако не все провайдеры выдают токены обновления, доступность токена обновления определяется поставщиком API.

# Приемы использования в Postman
Если ничего не облегчать, то необходимо так проектировать API, чтобы он выдавал ACCESS TOKEN и Refresh Token. Сторонними приложениями access token выдается с маленьким сроком жизни.
Как тестировать приложение, когда access token протух и мы не можем тестировать приложение без запроса нового токена?
Пример в подглаве ниже
## Пример как получить доступ к API GITHUB с помощью OAuth2.0 в Postman
Но вообще лучше смотреть видео
https://docs.google.com/document/d/1gj8JfFjpqE2w0c7SfbVV3uIFalNtz9DgN1gQstJAzRU/edit?usp=sharing

1. Создать и зарегистрировать ваше приложение, использующее авторизацию github (https://github.com/settings/applications/new): 
![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfCSLWk_6HEpCL59nMMrteBBnbqqJCo98Kd6wRYIsYoin5ZTdGS7-wNd3kXyE8-gXr_0pDJT3OUrWm3g6duBxGQLxZY3YG_jHtIee9FNqEuRLFprvqzMy3Z2XQ_Q-_xCX61xSO3ojmF6Il0C4fTdqo5--df?key=NDYUTKWaeqp0Lo01Zy83qQ)

Redirect URI для web-версии postman [https://oauth.pstmn.io/v1/browser-callback](https://oauth.pstmn.io/v1/browser-callback) , для версии desktop –  [https://oauth.pstmn.io/v1/callback](https://oauth.pstmn.io/v1/callback). Сохраните полученные ключи Client ID и Client secrets:
![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfWu1L8iF7rTr_Gd5-cAXKieib6omSXoPXxIoimO0sfyhOSJQFJBtutma9WjLbH3jOCnbT0ZCVQ6EMKCB5mtDYenwKMjSIWKxU6XmtfkuGT-Vmhm4-Mzj01bdIS_480drMluYeXaJaLURkNpLgZlbKPNAEk?key=NDYUTKWaeqp0Lo01Zy83qQ)

Далее перейдите в интерфейс postman и создайте новую коллекцию

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXeyGXK_kSSnb75mXe4UMAG4dRdo0uWwHxDdEzgZmyHKkAe5bUkYrmRIZsmtg1Pf6jwWsEyyY0LahNueKEhVJHfZ_UTnL5qM_vLgu7cpz84yeTkNu1ieXok4H4BQUq3ZRiDsLOZMTjiS9uF-I_Q5oEV9Ot9_?key=NDYUTKWaeqp0Lo01Zy83qQ) 

Далее в разделе Configure New Token укажите полученные данные и данные для запросов к серверу авторизации и получения токенов:

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcV1GTZS7p2LmJOJUU3zS0-wAUi-nUEmp8trEcxX882Ry7ZgKyJEojdXLcnv3wzrvQjbrGM1lFyvapZ-Q9dLQ0p1NfriXyKUZZhNd5sqhzmyDSb3OMTfz9NPpgDNyLhagX3ViUsan13N7u01uRmquKyQzlV?key=NDYUTKWaeqp0Lo01Zy83qQ)

  

Подробности про Auth URL и Access Token URL github см. в документации [https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps](https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps).

  

Далее получите новый access token:

  

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXfWaU3jVi74gtRj-NgId--7QrBdO_tLnB949ZErSYx0yNLFR5V4uDEnecm4XcPA8NicXMbdigBKtRulNtoyZmz-PKq0wkQaJ5NVnPY9MA5piMjT6FJwlD2OyXC7sv9hiOee1x6R8754dPHcP2vvzDrUufA?key=NDYUTKWaeqp0Lo01Zy83qQ)

  

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXey9hi1rX9RC-x5-VwpGaLqCgWa0zn-l1Opxsfh2TFiLlBvBX_UAdcVH3HQUKC1MK94ZEE-Vbni30FCuAswURvYLSAXi7BE7CqQvuVICiEycHXqnGyTShr3zunavLAoYM2s5vO7HKRtOmUVyLmCweU4HS0?key=NDYUTKWaeqp0Lo01Zy83qQ)

Выполните запрос к api github:

![](https://lh7-rt.googleusercontent.com/docsz/AD_4nXcM5dxHHIYHwUc_mpQXT5yAAmE_4fmMhpIio6xloEofRhgapUbOJ_Vs8zGLt_9Jnvf52Wf3M0MU6B7k8q9git1_7miJPZ8xVCGykCQ39wLWbvYaqy0O7g_zucyZGMcOjUIz-ty_9ocqCD_WSqQoto82pQ6R?key=NDYUTKWaeqp0Lo01Zy83qQ)

Подробнее про api github – https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-public-repositories](https://docs.github.com/en/rest/repos/repos?apiVersion=2022-11-28#list-public-repositories)

Redirect URI для web-версии postman [https://oauth.pstmn.io/v1/browser-callback](https://oauth.pstmn.io/v1/browser-callback) , для версии desktop –  [https://oauth.pstmn.io/v1/callback](https://oauth.pstmn.io/v1/callback). Сохраните полученные ключи Client ID и Client secrets:

Полезные материалы:
1.Аутентификация в веб-API: пример и ликбез по Postman https://babok-school.ru/blogs/authentication-vs-authorization-in-web-api-and-postman/
2.How to access Google APIs using OAuth 2.0 in Postman https://blog.postman.com/how-to-access-google-apis-using-oauth-in-postman/

# Авторизация через JWT токены
[основа](https://github.com/enkryptor/papers/tree/main/jwt-sso-authorization)
![[Pasted image 20250419230643.png]]Реализация аутентификации и авторизации для пользователя скрыта. Пользователь понятия не имеет как происходит этот процесс, да ему и не нужно это знать. Далее рассматриваются варианты реализации с точки зрения разработчика.
Большая предыстория, чтобы понять контекст текущего решения.
## Вариант №1. Реализация по логину и паролю
![[Pasted image 20250419230839.png]]Пользователь просто вводит креды, которые требует сайт. Архаичный механизм, сейчас так почти никто не делает из-за ненадёжности в плане ИБ.

Редкое исключение — секретная ссылка на действие (например для отписки от рассылки или удаление документа).

Минусы:
- Браузер хранит пароль и передаёт в каждом запросе
- Зная пароль, злоумышленник может незаметно им пользоваться
- Нельзя закрыть доступ злоумышленнику, не изменив пароль
- Не получится менять пароль достаточно часто
## Вариант №2. Сессия пользователя.
Также историческая история, но была создана, чтобы решить проблемы с вариантом №1.
Суть решения — разделить идентификационные данные (credentials-креды) и токен авторизации (некий секрет использующийся для авторизации, но не тот секрет который знает пользователь. Эти 2 секрета разделили). Для авторизации используется временный session-id.
![[Pasted image 20250419231213.png]]
После того, как клиент отправляет логин/пароль, веб-сервер генерирует некий секрет - айдишник сессии и сохраняет его в свою отдельную СУБД. 
Секрет передается пользователю, считается, что клиент аутентифицирован.
Клиент во всех своих запросах передает ID сессии. Пароль ушел из запросов клиента, теперь он отдает только ID сессии.
Когда пользователь разлогинивается ID сессии удаляется из БД и перестает быть валидным в отличии от пароля.

Теперь пароль передается один раз.
Злоумышленник может натворить делов только в рамках сессии. 
Сервер может уведомлять пользователя об открытии сессии (приходит сообщение, что пользователь зашел).

Минусы:
- все еще есть потребность отправлять креды при смене сессии
- Проблемы масштабирования - веб-сервер работает в режиме stateless и не помнит своего состояния, и их можно масштабировать в случае увеличения нагрузки, создать несколько экземпляров. А СУБД помнит сессию, возникает противоречие - необходимо распределять юзеров по БД до их аутентификации и все-таки выходит, что БД остается одна,  надежно это сделать нельзя. БД становится не масштабируемой (например 10к запросов в секунду).
## Вариант №3. JWT токен.
Решает проблему масштабирования БД из прошлого варианта.

Суть решения — автоматическая смена секрета (токена авторизации) на стороне веб-сервера. Когда Access token протухает, refresh token его постоянно обновляет и это может происходить очень долго (вплоть до года или какие настройки мы зададим) при этом пользователь не вводит пароль.
Если в сессии токен менялся только когда пользователь перелогинивался, то в токенах это происходит автоматически без действия пользователя. Как это работает?
После аутентификации клиент получает два токена — Access Token и Refresh Token. Access Token используется как session-id и так же ограничен по времени.

![[Pasted image 20250419233111.png]]В первый раз пользователю все равно надо отослать логин пароль.
Сервер присылает Access Token (маленький срок действия 5-15 минут), Refresh Token. 

Когда Access Token протух:
![[Pasted image 20250419233456.png]]
После протухания веб-сервер выдает ошибку. Но клиентское приложение может попытаться обновить токены само, послав Refresh Token и получить новую пару токенов.

Refresh Token одноразовый, используется для обновления Access Token'а.

Токен отличается от ID сессии тем, что это не просто секрет, а криптографически подписанные данные некие.
В JSON токенах не передаются секреты

Цифровая подпись - некий артефакт, который владелец ключа может добавить к тексту и опубликовав свой публичный ключ он может дать его позволить проверить любой заинтересованной стороне.
Потребитель может проверить что этот токен выдал определенный сервер и при этом он не может подделать подпись.
![[Pasted image 20250419234207.png]]

Короче со всей этой хренью решается проблема масштабирования. Можно сделать проверку токена без базы данных. На бэкэнде можно создать несколько сервисов и через балансировщик регулировать нагрузку имея один секретный ключ могут проверять валидность токенов и авторизовать пользователя или нет.

Важная особенность — токен это JSON с идентификатором пользователя, подписанный криптографической подписью. Никакие секретные ключи в запросах не передаются.

Формат токена — строка `{заголовок}.{тело}.подпись`, закодированная в base64.

Пример: [https://jwt.io/](https://jwt.io/)

Можно проверить через [https://www.base64decode.org/](https://www.base64decode.org/)

Тело хранит идентификатор пользователя и время действия токена, а подпись гарантирует подлинность. Криптография даёт возможность не хранить токен в БД, как id сессии, а проверять валидность токена распределённо.

Токен кодируется в base64, чтобы упростить его хранение и передачу в виде текста.

На клиенте токен хранится в куки или в локальном хранилище браузера (хранится в коде фронтенда):
- Хранение в локальном хранилище дает доступ к токену клиенту, это и плюс и минус (уязвимость к CSRF).
- Хранение в httpOnly кукис не даёт возможности прочитать токен из скриптов на стороне фронтенда (более безопасно).

# SSO
"Технология единого входа". Решаемая проблема — исключить хранение и передачу кред. Суть решения — делегировать задачу аутентификации стороннему провайдеру. Это позволит клиенту вообще не присылать критичные данные (логин-пароль), если он уже аутентифицирован на стороне провайдера. Чтобы эта схема заработала, и потребитель и клиент должны заранее зарегистрироваться у провайдера.

Невозможно украсть пароль если он не передается.

Аутентификация происходит на стороннем провайдере. И клиентское (client) и серверное (consumer) приложение должны на нем зарегистрироваться.
![[Pasted image 20250420084520.png]]

После этого Client может аутентифицироваться у Consumer не присылая свой пароль, а присылая сгенерированный токен который постоянно меняется.
Провайдер только предоставляет API через который можно подтвердить подлинность.

Существуют различные протоколы SSO
![[Pasted image 20250420084915.png]]
LDAP — централизованная директория аккаунтов; не подходит для сайтов в интернете.

OAuth/OAuth2 — может авторизировать действия приложения-клиента у провайдера (api). RFC 6749, 2008-2013 года.

OpenID — аутентификация пользователя, новые версии работают поверх OAuth2.

WebAuthn — поддержка большего количество средств аутентификации (напр. биометрия); другое название — Web Authentication API.

Другие протоколы: SAML, Kerberos (оставим за кадром).

OAuth изначально разрабатывался как API доступа между различными сервисами. Сервис №1 запрашивает права у Сервиса №2. На этой базе сделали аутентификации пользователей - OpenID Connect.

Bearer token - схема аутентификации по http через токен. Носителю данного токена предоставить данные привилегии. Общее название механизма передачи http-header в определенном виде.+

