Введение
[основа 1](https://habr.com/ru/companies/clevertec/articles/879654/) 
[основа 2](https://habr.com/ru/companies/clevertec/articles/897386/)
*В случае необходимости более глубокого погружения в тему, в обоих основах в конце много приложений, которые можно прочитать, т.к. они неплохо раскрывают тему.*
Вообще на хабре довольно много статей по KeyCloak, поэтому можно будет найти в случае чего.
Связи с:
[[Аутентификация]]
[[Проектирование логики аутентификации и авторизации]]
# Межсистемная аутентификация
## Дано №1
Дано №1 (взято из фуллстек тестирования):
![[Pasted image 20250504155558.png]]
Для начала предположим, что конечный пользователь пытается войти в приложение, вводя свои учетные данные. Уровень пользовательского интерфейса передает учетные данные сервису аутентификации Auth, а тот, в свою очередь, — в базу данных для проверки подлинности. Если введенные учетные данные совпадают с хранимыми, то служба аутентификации (предположим, что она действует в соответствии с протоколом OAuth 2.0, https://oreil.ly/FgEwf) возвращает токен доступа и сохраняет его в кэше. Это ключевой фрагмент внутренних данных приложения, потому что любой последующий запрос от пользователя будет сопровождаться этим токеном доступа, доказывающим, что запрос отправлен конечным пользователем, подтвердившим свою личность.

Пойдем дальше и представим, что пользователь пытается разместить заказ из пользовательского интерфейса. Уровень пользовательского интерфейса создает запрос для отправки сервису управления заказами Order и добавляет токен доступа в заголовок запроса. Служба управления заказами связывается со службой аутентификации, чтобы убедиться, что токен доступа действителен, а служба аутентификации, в свою очередь, запрашивает кэш. Если срок действия токена доступа уже истек, то кэш автоматически удалит его и сервисы вернут код состояния 404. Получив ответ 404, пользовательский интерфейс перенаправит пользователя обратно на страницу входа.

## Дано №2
Дано №2 (взято из статьи): взаимосвязь на основе микросервисной архитектуры
![[Pasted image 20250504155153.png]]

Фактор аутентификации - блок данных для аутентификации субъекта или объекта доступа. Какие либо категории свойств пользователя которые являются уникальными и позволяют однозначно определить пользователя или систему.

Выделяют 3-5 факторов аутентификации:
- поведение;
- геолокация;
- знание;
- владение;
- неотъемлимая часть субъекта;
![[Pasted image 20250504155911.png]]

Двухфакторная аутентификация разными способами лучше однофакторной.

# Способы аутентификации
По паролю.
По сертификату.
По одноразовому паролю.
По ключам доступа.
По токенам.

Подробнее каждый способ надо гуглить (или можно чуть глянуть статью), т.к. у каждого способа свои достоинства и недостатки. В статье в основном рассказывается про токены.
### Вводная про токены
**Federated identity management (FIM)** — соглашение между двумя или более доменами или системами управления идентификацией о доверительном отношении. Самое широкое понятие, которое может включать (а может и нет) остальные.
**Single sign-on (SSO)** — метод аутентификации, который позволяет пользователям безопасно аутентифицироваться сразу в нескольких приложениях и сайтах, используя один набор учетных данных. Например, через аутентификацию через соцсети. 
**OAuth 2.0** — стандартный протокол авторизации, который определяет механизм получения доступа одного приложения к другому от имени пользователя. Заметьте, что именно авторизации, то есть получение ролей тоже возможно. 
**OpenID Connect (OIDC)** — уровень аутентификации, наложенный на базу OAuth 2.0, чтобы обеспечить фунциональность SSO (дополнительный токен с данными о пользователе).
**Security Access Markup Language (SAML)** — открытый стандарт, который также разработан для обеспечения функциональности SSO, описывает способы взаимодействия и протоколы между identity provider и service provider для обмена данными аутентификации и авторизации посредством токенов.

![[Pasted image 20250504160808.png]]Если кто-то использует SSO, то совсем не факт, что и протокол авторизации будет OAUTH2.0
Но если говорят, что используют OIDC, то это однозначно SSO + OAUTH2.0

SAML - Security Assertion Markup Language
#### Токен
Токен - фактор аутентификации.
В контексте аутентификации по токенам могут быть:
*Аппаратный токен* устройство, позволяющее идентифицировать его владельца и обеспечивающее безопасный доступ к ресурсам. Как правило, такое устройство либо содержит, либо генерирует уникальный пароль по определенным правилам. Обычно используется, как дополнительный фактор при аутентификации пользователя.  
  
**Программный токен** представляет собой зашифрованную строку символов, которая позволяет аутентифицировать пользователя или систему, а также определить уровень прав (т.е. авторизировать). Токен может также содержать дополнительную информацию и использоваться многократно, пока не истечет срок его действия.**

#### Как может шифроваться токен?
1. **Simple Web Token (SWT)** — наиболее простой формат, представляющий собой набор произвольных пар имя/значение в формате кодирования HTML form. Подписывается симметричным ключом.
2. **Security Assertion Markup Language (SAML)** — определяет токены (SAML assertions) в XML-формате, включающем информацию об эмитенте, о субъекте, необходимые условия для проверки токена, набор дополнительных утверждений о пользователе. Подписывается ассиметрично.
3. **JSON Web Token (JWT)** — содержит заголовок, набор полей (claims) и подпись. Первые два блока представлены в JSON-формате и дополнительно закодированы в формат base64. Может подписываться и симметрично, и ассиметрично.
#### Механизм аутентификации при помощи программного токена
**Клиент (client)** — приложение или пользователь, которые аутентифицируется.
**Сервис (service provider SP)** — приложение, доступ к которому хочет получить клиент и которое делегирует аутентификацию третьей сущности.
**Провайдер идентификации (identity provider IP)** — приложение, обеспечивающее идентификацию, аутентификацию, а зачастую и авторизацию client.

![[Pasted image 20250504161452.png]]
Если клиент напрямую попробует обратиться к сервису, то скорее всего сервис отправит его провайдеру идентификации за токеном, но чтобы не усложнять схему выше, давайте представим, что клиент уже и так знает, что без токена к сервису нечего и соваться.

1. **Аутентификация клиента провайдером идентификации IP.** Реализовать процесс можно любым образом, в простейшем случае это аутентификация по логину и паролю, но может быть и любая другая. Например, двухфакторная по паролю и по локации. Главное, чтобы IP мог идентифицировать, аутентифицировать (а при необходимости и авторизовать) клиента.
2. **Генерация и передача клиенту токена.** После того, как IP идентифицировал клиента, создается фактор аутентификации для конкретного клиента — токен, в который зашивается вся необходимая информация (про токены и какие они бывают поговорим чуть позже). Токен передается клиенту, который, как правило, хранит токен где-то у себя пока сохраняется его срок действия.
3. **Аутентификация сервером по токену.** Вот теперь клиент может отправить запрос серверу только с дополнительной нагрузкой в виде токена, по которому будет проходить аутентификация.
4. **Валидация токена сервером.** В целях безопасности валидировать токен все-таки надо — не истек ли срок, тем провайдером был выдан и тому ли клиенту, соответствует ли тело подписи, верны ли утверждения. На схеме изображено, что сервер проверяет токен, обращаясь к IP, но есть варианты, где сервер валидирует токен самостоятельно.
5. **Ответ и возвращение ресурса.** Если валидация прошла успешно, то сервер вернет соответствующий ответ. Кстати, может быть и 403, потому что авторизация — немного другая история, а коды ошибок должны быть информативными.

# KeycLoak
Также много всего в статье и после нее. Если необходимо, то читай более плотно её.

Keycloak позволяет осуществлять межсистемную аутентификацию по токенам. Он поддерживает аутентификацию и авторизацию в приложениях со стандартными протоколами OpenID Connect, OAuth 2.0 и SAML 2.0. Еще один фактор делает Keycloak таким привлекательным — это open source.

Основные характеристики Keycloak:

- **Регистрация и управление пользователями/сервисными аккаунтами**: возможность создавать и настраивать пользователей/сервисные аккаунты, управлять их правами и группами.
- **Single Sign-On (SSO) и Single Sign-Off**: единая аутентификация для всех приложений в пределах одного realm (об этом чуть ниже) и возможность разлогинивания сразу из всех систем.
- **Выдача JSON Web Token (JWT)**: обеспечение безопасной передачи данных между клиентом и сервером с помощью стандартного формата токенов. 
- **Интеграция со службами каталогов (LDAP, Active Directory)**: возможность подключения к корпоративным каталогам для управления учетными записями.
- **Брокер Kerberos**: реализация аутентификации через Kerberos в корпоративной среде.
- **Поддержка мульти-realm**: создание изолированных пространств для пользователей и приложений с возможностью кастомизации логин-страниц для каждого realm.
А если вспомнить, что кроме межсистемной есть пользовательская аутентификация, то к списку выше можно добавить:
- **Авторизация через соцсети**: поддержка входа через сторонние провайдеры, такие как Google, Facebook, GitHub и другие.
- **Двухфакторная аутентификация (2FA)**: поддержка дополнительной проверки личности через OTP, аутентификационные приложения и другие методы.

## Как работает KeyCloak
Аналогично аутентификации по токенам
![[Pasted image 20250504163011.png]]
Итак, **access-token** — это собственно и есть токен доступа, который система А будет отправлять системе B, чтобы подтвердить, что ей можно доверять и предоставлять допуск к ресурсам. Как правило, это JWT, который содержит всю необходимую информацию, включая, например, роли для последующей авторизации. Этим токеном могут пользоваться все инстансы системы. Однако, как и у всех токенов, у него есть lifespan — «срок годности», по истечению которого он перестает быть действительным. Время действия токена определяется настройками Keycloak для конкретного клиента в конкретном realm и зависит от того насколько чувствительными данными планируется обмениваться между системами и может отличаться для разных групп и ролей. Обычно время жизни access-token  составляет от 3 до 10 минут.

Но что же делать, если срок действия истек, а запросы все не заканчиваются? Снова и снова обращаться к Keycloak, каждый раз проходя авторизацию заново, не так уж и плохо, но это может стать узким местом и снизить скорость работы. Но вы же помните, что бывают еще и **refresh-token**? Этот токен как раз предназначен для облегчения получения нового access-token: клиенту не нужно повторно проходить авторизацию у Keycloak, а достаточно предоставить валидный refresh-token. И да, lifespan тоже можно настроить и, как правило, он подольше, чем у access-token и обычно составляет 15-30 минут, а иногда и до нескольких часов.

Кроме того, для дополнительной безопасности, можно обеспечить **ротацию** refresh-token. Всякий раз, когда система обращается за новым access-token, она заодно получает и новый refresh, а старый перестает быть валидным. Это предотвращает переиспользование refresh-token и сокращает риски при перехвате токена. Повторно проверку он просто не пройдет. И конечно, не стоит хранить такие вещи в открытом виде и использовать для передачи небезопасные соединения.