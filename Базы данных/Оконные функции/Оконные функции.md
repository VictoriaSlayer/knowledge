# Введение
Реляционный подход основан на наборах и множествах данных.
Множество - под множеством мы подразумеваем любое объединение М в одно целое, состоящее из определенных различающихся объектов м (называемых элементами М) в области наших мыслей и восприятий.
Целое - множество должно восприниматься и управляться как единое целое. Мы должны с ним работать как с общностью данных, а не как с разрозненным набором элементов.
Отношение - общность похожих элементов обладающих одинаковым набором атрибутов.

Взаимодействуя с таблицей, мы с ней взаимодействуем как с целым, а не как с набором отдельных строк.
На самом деле набор данных обрабатывается как единое целое, без итераций.

С точки зрения языка запрос выполняется на основе набора данных (множества), а не на основе итераций со строками.

## Пример
``` sql
select orderid, orderdate,val,
	rank() over(order by val desc) as rnk
	from sales.OrderValues
```
# Как работает оконная функция?
Идея оконных функций состоит в определении набора строк/окна в рамках которого будет действовать функция.
1. Оконная функция логически определяет для каждой строки в результирующем наборе данных запроса отдельное, независимое окно. ![[Pasted image 20250724204001.png]]
2. Если нет никаких ограничений в запросе, то каждое из окон будет состоять из набора всех строк результата запроса.
3. При этом вы можете добавить ограничения в спецификацию окна (секционирование, определение границ окна и т.д.), которое будет дополнительно ограничивать набор строк для каждого из них.

## Оконные функции VS Group by
Group by позволяет проанализировать информацию для агрегированных значений без возможности посмотреть детализацию.
Применив группировку мы ограничиваем наши запросы контекстом этой группировки.
В случае если необходимо применить калькуляции, затрагивающие как агрегаты, так и исходные данные выручает оконка.

## Чуть больше объяснений
Для определения окна в рамках которого будет работать функция используется инструкция OVER
SUM(val) OVER()
Если скобки пустые, то мы не ограничиваем окно и оно работает на весь результирующий набор данных.

SUM(val) OVER(PARTITION BY custid)

### Как выполняются подзапросы
В случае запроса с вложенным подзапросом, вложенный подзапрос начинает свое выполнение с нуля, а не на базе родительского запроса.
Таким образом если мы хотим, чтобы подзапрос выполнялся в том же наборе данных, что и базовый запрос, необходимо повторить все конструкции основного запроса.

Оконки же действуют на основе результирующего набора, снижая нагрузку на сервак.