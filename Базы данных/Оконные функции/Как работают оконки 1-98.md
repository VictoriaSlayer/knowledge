# Окно
Вся работа с оконными функциями делится на 3 части:
- продумывание логики запроса - что мы хотим видеть;
- определение окна в рамках которого будем производить расчеты;
- определение функции, которая будет делать вычисления в рамках интересующего нас окна;
## Что такое окно?
Допустим есть сотрудники отдела и необходимо составить рейтинг сотрудников отдела по заработной плате

![[Pasted image 20251130171137.png]]

Эту историю можно осуществить с помощью следующего запроса

```SQL
  select  
  dense_rank() over (order by salary desc) as 'rank',  
  name,  
  department,  
  salary  
  from employees
```

Для того, чтобы понимать, как работают оконки, необходимо вспомнить как происходит выполнение запроса
![[Pasted image 20251130171718.png]]
```SQL
  select  
  dense_rank() over (order by salary desc) as 'rank',  
  name,  
  department,  
  salary  
  from employees
```
Итак что происходит:
- в начале берём таблицу указанную from;
- выбираем из неё все записи согласно порядка;
- *и теперь мы создаем окно* -  over (order by salary desc), к которому мы будем делать вычисления;
- order by salary desc - определяет сортировку этого окна, в каком порядке к нему делать вычисления;
- dense_rank () over - а здесь мы определяем функцию которая делает вычисления к нашему окну;
- order by;

Order by в окне задает порядок сортировки окна. Order by в основном запросе задает сортировку того, что нам выведет.

Анимация - gif to#w22rnk.

# Секция/партиция окна
Допустим нужен рейтинг сотрудников по размеру заработной платы независимо по каждому департаменту
![[Pasted image 20251130173545.png]]
Порядок реализации графически
![[Pasted image 20251130173625.png]]
Выделенная рамка это и есть секция. Как выделить секцию?
- необходимо выделить окно;
- в рамках окна необходимо выделить секцию;
- в рамках секции необходимо определить сортировку;
- к шагам 2-3 применяется функция;

```SQL
  select   
  dense_rank() over (partition by department order by salary desc) as 'rank',  
  name,  
  department,  
  salary  
  from employees  
  order by department, 'rank', id
```

partition by department - выделяет секцию;
order bu salary desc - определяет сортировку;
dense_rank() - оконка начинает рассчитчывать функцию;

Анимация - to#w22prt
## Функция ранжирования
```SQL
row_number() - порядковый номер строки, number
dense_rank() - ранг строки rank
rank() - ранг строки, но с пропусками
ntile() - разбивает все строки на N групп и возвращает номер группы, в которую попала строка
```
# Сравнение со смещением
Сравнение со смещением - когда мы смотрим в чем разница между соседними значениями. Например как сильно отличаются показатели 1 и 6 места или 5 и 6 и т.д.
![[Pasted image 20251130175637.png]]
Столбец diff показывает на сколько процентов зарплата сотрудника отличается от предыдущего коллеги.
Автор предлагает следующий алгоритм:
- делаем скользящее окно текущего и предыдущего значения;
- ![[Pasted image 20251130180758.png]]
- а уже потом находим %;
- ![[Pasted image 20251130180812.png]]
to#w23lag

В SQL можно задать скользящее окно, но автор предлагает эту тему оставить на будущее. Сейчас же воспользоваться функцией lag():
```SQL
select
	id,
	name,
	department,
	salary,
	lag(salary, 1) over (order by salary id);
	from employees
	order by salary, id
```

lag() - возвращает значение из указанного столбца, отстоящее от текущего на указанное количество записей назад.

теперь находим % при помощи CTE:
```SQL
	  with emp as(  
	  select  
	    id, name, department, salary,  
	    lag(salary, 1) over (order by salary, id) as prev  
	  from employees  
	  )  
	  -- Находим скользящую разницу
	  select  
	    name, department, salary,  
	    round(  
	    (salary - prev)*100/prev,  
	     1) as diff   
	  from emp  
	  order by salary, id
	  -- находим % по скользящей разнице
```

# Фрейм
Иерархия окон в SQL:
окно > секция > фрейм.
Внутри окна находится секция, внутри секции находится фрейм.
![[Pasted image 20251130183628.png]]
Начало фрейма - начало секции
Конец фрейма - конец текущей записи. В данном случае Марины.
Фреймы можно переопределять!!! Например сделать так, чтобы фрейм заканчивался в конце секции. Это можно сделать при помощи функций:
first_value() и last_value() - работают с фреймом внутри секции.

Как они работают:
- есть окно, которое состоит из одной или нескольких секций - (partition by department);
- внутри секции записи упорядочены по конкретному столбцу - (order by salary);
- у каждой записи в секции свой фрейм. По умолчанию начало фрейма совпадает с началом секции, а **КОНЕЦ ДЛЯ КАЖДОЙ ЗАПИСИ СВОЙ**;
- конец фрейма можно приклеить к концу секции чтобы фрейм точно совпадал с секцией;
- first_value() - возвращает значение из первой строки фрейма;
- last_value() - возвращает значение из последней строки фрейма;
Анимация gif - to#w23frm

```SQL
	select  
	  name, department, salary,  
	  first_value(salary) over (partition by department order by salary rows between unbounded preceding and unbounded following) as 'low',  
	  last_value(salary) over (partition by department order by salary rows between unbounded preceding and unbounded following) as 'high'   
	  from employees  
	  order by department, salary, id
```

Анимация gif - to#w23nth

## Значения фрейма
```SQL
rows between 
-- задаем фрейм
unbounded preceding
-- начало фрейма, начало фрейма = начало партиции
and
unbounded following
-- конец фрейма = конец диапазона после строки
-- current row - текущая строка
```
## Функции смещения
lag(value, offset) - значение value из строки, отстоящей на offset строк назад от текущей;
lead(value, offset) - значение value из строки, отстоящей на offset строк вперед от текущей;
first_value(value) - значение value из первой строки фрейма;
last_value(value) - значение value из последней строки фрейма;
nth_value(value, n) -  - значение value из n-строки фрейма;

# Агрегация общая
Агрегация - то, когда мы считаем суммарные или средние показатели. Средняя ЗП по регионы и т.д.
Какой % от ФОТа составляет ЗП каждого сотрудника?
![[Pasted image 20251130185839.png]]

Логика расчета
![[Pasted image 20251130190236.png]]

```SQL
  select  
    name, department, salary,  
    sum(salary) over (partition by department) as fund,  
    round((salary*100.0/sum(salary) over (partition by department)), 0)  as perc  
    from employees  
    order by department, salary, id
```

Анимация gif - to#w24sum

## Функции агрегации
min(value) - минимальное value среди строк секции окна
max(value) - максимальное value среди строк секции окна
count(value) - количество value не равных null
avg(value) - среднее значение по всем value
sum(value) - сумма значений value
group_count(value, separator) - соединение значений value через разделитель separator SQLite, MySQL
string_agg(value, separator) - аналог group_concat() для MS SQL

# Скользящие агрегаты
Пример - скользящее среднее. Средний доход с учетом предыдущего и следующего месяца.
![[Pasted image 20251207154039.png]]
to#w25awg

1. Рамка на каждом шагу сдвигается вниз на одну строку, по ней производятся вычисления.
2. Окно состоит из одной или нескольких секций/партиций.
3. Внутри секции/партиции записи упорядочены по конкретным столбцам
4. У каждой записи свой фрейм.
```SQL
over (
order by year, month
rows between 1 preceding and 1 following
-- последняя строка как раз определяет фрейм
)
```

## ИСКЛЮЧЕНИЕ фреймы по умолчанию
Имеется запрос
```SQL
select  
  year,  
  month,  
  expense,  
  sum(expense) over (  
    order by year, month  
    rows between unbounded preceding and current row  
  ) as total  
  from expenses  
  order by year, month
```
![[Pasted image 20251207160159.png]]
В случае если мы из запроса убираем определение фрейма
```SQL
select  
  year,  
  month,  
  expense,  
  sum(expense) over (  
    order by year, month  
  ) as total  
  from expenses  
  order by year, month
```
![[Pasted image 20251207160354.png]]
Ожидаем - запрос без фрейма посчитает суммарные результаты.
Реальность - запрос без фрейма посчитал накопительные результаты.

Всё из-за наличия в окне сортировки (order by year, month).

Правило:
- если в окне есть order by;
- и используется функция агрегации;
- и не указано определение фрейма;
- то фрейм используется по умолчанию;
- фрейм от первой до текущей записи - rows unbounded preceding and current row
## Функции скользящих агрегатов
Аналогично функциям обычных агрегатов.
