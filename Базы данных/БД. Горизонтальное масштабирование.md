Имеется вертикальное и горизонтальное масштабирование.
То как я понимаю - перспективно уходить в облако, где вендор предоставляет SaaS и это уже его проблемы сколько ресурсов он тебе предоставит.
Сейчас если вы:
- не работаете с BigData;
- вам не важно SLA с пользователем на уровне 99,9999%;
- у вас недостаточно денег на мощности (а они дороже горизонтального масштабирования);
То вы можете уйти в вертикальное масштабирование.
# Вертикальное масштабирование
https://habr.com/ru/articles/755626/
При вертикальном масштабировании мы просто добавляем мощности.
Архитектуры с горизонтальным масштабированием в целом считаются более надёжными; они проектируются с расчётом на сохранение работоспособности даже в условиях различных отказов. Но в системах с горизонтальным масштабированием не удалось серьёзно повысить надёжность, а при вертикальном масштабировании они обычно отличаются солидной надёжностью.
Как показывает практика, провайдеры облачных горизонтально масштабируемых баз данных и сопутствующей аналитики обеспечивают SLA уровня 4-9 (доступность в 99,99% случаев).

# Горизонтальное масштабирование
https://habr.com/ru/articles/875708/
Концепции статьи частично пересекаются со сложным интервью Алекса Сюя.
Имеется 3 варианта:
- репликация;
- партиционирование;
- шардирование;
## Репликация
**Репликация базы данных** — это процесс автоматического копирования и синхронизации данных между несколькими серверами (узлами). При репликации изменения, внесённые в одну копию базы (основной узел), автоматически передаются на другие узлы (реплики), которые могут использоваться для балансировки нагрузки, резервного копирования или аналитики.

Суть репликации заключается в существовании множества копий базы, имеющих весь набор данных. В случае выхода из строя или большой нагрузки на один узел, запросы перенаправляются на другой.
Не всегда все реплики имеют равные права. Существует 2 сценария: _Master-Slave_ и _Master-Master_.

- **Главная СУБД (Master Database)** — это оригинал. Имеет доступ ко всей информации в соответствии со всеми уровнями запросов
- **Подчиненная СУБД (Slave Database)** — копия или реплика главной СУБД. Ее функциональность может отличаться от оригинально
### Master — Slave
**Master-Slave** репликация — это способ организации базы данных, где есть один главный сервер (Master) и один или несколько подчинённых (Slave). Master принимает все запросы на запись (добавление, изменение, удаление данных), а Slaves только читают данные и получают обновления от Master.
![[Pasted image 20250204214652.png]]
#### Как это работает?
1. Клиенты записывают данные только в Master. 
2. Master автоматически передаёт изменения Slaves.
3. Клиенты могут читать данные как с Master, так и с Slaves (чаще читают со Slaves, чтобы снизить нагрузку на Master).
#### Плюсы
- Разгрузка Master — чтение можно распределить по нескольким Slaves, что повышает производительность.
- Резервирование — если Master сломается, можно переключиться на один из Slaves.
- Масштабируемость — можно добавлять новые Slaves без перегрузки основного сервера.
#### Минусы
- Задержка синхронизации — данные на Slaves могут немного отставать от Master.
- Если Master падает, вручную или с помощью дополнительных механизмов нужно выбрать нового. Необходимо предусмотреть сценарий и алгоритм, при котором Slaves узлы самостоятельно выберут нового Master среди себя.
- Не подходит для интенсивной записи — так как записи идут только в один узел, он может стать узким местом.
### Master — Master
**Master-Master** репликация — это когда у базы данных есть два (или больше) главных сервера, и каждый из них может одновременно принимать и обрабатывать запросы на запись и чтение. Данные между серверами автоматически синхронизируются, чтобы оставаться одинаковыми.
![[Pasted image 20250204215016.png]]
#### Плюсы
- Высокая отказоустойчивость — если один сервер выходит из строя, другой продолжает работать.
- Балансировка нагрузки — можно распределять запросы между серверами, снижая нагрузку на каждый из них.
- Быстрее для географически распределенных систем — пользователи могут работать с ближайшим сервером, уменьшая задержки.
#### Минусы:
- Конфликты данных — если два сервера изменяют одни и те же данные одновременно, могут возникнуть проблемы с их синхронизацией. Главной задачей разработчика системы станет гарантировать согласованность данных, что по CAP теореме повлечет снижение Доступности или Готовности к разрыву сети.
- Сложность настройки и поддержки — требуется механизм разрешения конфликтов и контроль синхронизации.
- Задержки репликации — хотя данные синхронизируются, это не всегда происходит мгновенно, что может привести к временным рассинхронизациям.

В некоторых сценариях, репликация не решит все ваши проблемы, а иногда только создаст дополнительные. Второй популярной стратегией масштабирования БД является _партицирование_.
## Партиционирование
**Партицирование** базы данных — это метод разбиения большой таблицы в рамках единой базы на более мелкие, логически связанные части (партиции). Каждая партиция хранится отдельно,но логически объединяется в одну таблицу, а база автоматически направляет запросы в нужные партиции.

Существует 2 способа партицировать таблицу — _горизонтально_ и _вертикально_.

**Вертикальное партицирование** — не самый популярный, но заслуживающий упоминания вариант. При данном подходе таблица разделяется на партиции по принципу выбранных колонок. Например, если у вас есть таблица users с полями id, name, age, fav_sport, fav_food, то можно разделить её на партиции users_identity с полями id, name, age и users_preferences с полями id, fav_sport и fav_food.

Важно грамотно выбрать ключевые колонки дробления, чтобы равномерно распределить нагрузку. Ведь если программа 90% запросов будет направлять в партицию 1, а лишь оставшиеся 10% в партицию 2, то значит мы партицировали таблицу неправильно, и следовательно, теряем производительность.

![[Pasted image 20250204215127.png]]
**Горизонтальное партицирование** — более распространённый метод, заключающийся в делении таблицы по строкам. Например, таблицу consumers с полями city, name, и age можно разбить на таблицы по типу users_russia, users_ukraine, users_monaco. Однако опять же, важно помнить про равномерность распределения. Если предположить, что наш сервис распространен и в России и в Монако, то распределение на users_russia и users_monaco будет нерациональным, и не приведет к желаемому результату(потому что кол-во запросов из России очевидно будет много выше, так что проблема с большой нагрузкой от этой страны останется нерешенной). Кейс был приведен исключительно для наглядности, а конкретно в таком случае лучше будет выбрать другой принцип партицирования, чем регион.
![[Pasted image 20250204215143.png]]
P.S. методы шардирования _Key-Based_, _Range-Based_ и _Directory-Based_ о которых мы поговорим ниже, могут также применяться для выбора метода партицирования.
## Шардирование
Про варианты шардирования - проще лезть читать в статью.

**Шардирование** — это метод горизонтального масштабирования базы данных, при котором данные разделяются на независимые части (шарды) и хранятся на разных серверах. Каждый шард содержит только часть общей информации, но вместе они образуют полную базу. Это позволяет распределять нагрузку и увеличивать производительность системы, так как запросы к данным могут выполняться параллельно на разных узлах.

Основная задача шардирования — определить, каким образом данные будут распределяться между шардами. Чаще всего используются хеш-функции, диапазоны значений или географическое разделение. Однако шардирование добавляет сложность в администрирование, так как требует балансировки данных, управления кросс-шардовыми запросами и обеспечения целостности транзакций.
![[Pasted image 20250204215327.png]]
## Заключение
Масштабирование базы данных — ключевой аспект построения высоконагруженных систем. Репликация повышает отказоустойчивость и распределяет нагрузку на чтение, партиционирование и шардирование помогают эффективно управлять большими объемами данных, а выбор стратегии хеширования и методов перераспределения критически важен для минимизации даунтайма при решардинге.
### Что читать дальше?
- **Типы репликации** (логическая, физическая, асинхронная, синхронная) и их влияние на консистентность.
- **CAP‑теорема и PACELC** — компромиссы в распределенных системах.
- **Архитектуры распределенных баз данных** (DynamoDB, Spanner, Cassandra, CockroachDB).
- **Техники уменьшения межузлового трафика** (Bloom-фильтры, Merkle-деревья, компрессия).
Практикуйтесь, экспериментируйте с различными подходами и анализируйте их влияние на производительность системы.