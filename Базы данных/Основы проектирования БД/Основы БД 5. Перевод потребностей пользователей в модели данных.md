# Введение
Модель данных - способ представления базы данных, которую мы собираемся проектировать. Изучив детали модели можно решить, представлены ли в ней все данные, или нужно что либо еще.

Построив модель, можно задавать следующие вопросы (в целом вопросы относятся к CRUD модели). Варианты вопросов:
- где хранится информация о клиентах;
- сколько имен контактов одного клиента может быть;
- где хранятся любимые цвета контактов;
- что делать, если необходимо хранить несколько цен одного и того же товара;
- как хранить 17 видов нужных нам адресов клиентов;
- где хранить информацию о поставщиках;
- если кто-то спросит про заказ, который был сделан, но не получен, как можно выяснить, где он находится;
- где можно записать особые указания к заказу;
- как узнать, когда пора пополнять запасы инструментов для левшей;
# Виды моделей
## Модель пользовательского интерфейса
Представляет БД на очень высоком уровне - такой, как ее видит конечный пользователь. 
![[Pasted image 20250216221707.png]]
Заполняя поля и данные, проходя по UseCase получаем представление о предполагаемой структуре БД.

Можно сделать мокап UI чтобы показать пользователю и дальше задавать наводящие вопросы - о допустимых значениях, предустановленных значениях, логике хранения и т.д.
## Семантическая объектная модель
Семантическая объектная модель - на уровень ниже чем GUI.
Семантический класс - тип того, что мы желаем представить в системе. Сюда могут входить физ. объекты, люди, мебель, товары, счета-фактуры и т.д.
Технически семантический класс - именованная совокупность атрибутов достаточная для идентификации конкретной сущности. Класс **Пользователь** содержит *атрибуты* Имя, Фамилия.
Семантический объект - экземпляр семантического класса.
### Атрибуты
*Простой атрибут* - содержит простое значение. Строка, число, дата.
*Групповой атрибут* - составное значение. Address = Street + City + State + ZipCode. Мы могли бы их представить как отдельные атрибуты, но тогда бы терялся смысл.
*Атрибут объекта* - олицетворяет связь с другим семантическим объектом. Класс Студент будет иметь атрибут Курс, который будет ссылаться на другой объект.

*Кардинальность* - сколько значений этого атрибута может быть у объекта:
- 1.1;
- 1.N;
- 0.1;
- 0.N;

### Типы классов
*Простые объекты* - ключ значение.
*Композитные объекты* - по крайней мере один многозначный атрибут.
*Составные объекты* - по крайней мере один атрибут объекта.
*Гибридный объект* - комбинация других типов атрибутов.

| Project     |     |     |     |     | Developer   |     |
| ----------- | --- | --- | --- | --- | ----------- | --- |
| ProjectId   | 1.1 |     |     |     | DeveloperId | 1.1 |
| Description | 1.1 |     |     |     | FristName   | 1.1 |
| *Manager*   | 1.1 |     |     |     | LastName    | 1.1 |
| *Developer* | 1.N |     |     |     | *Project*   | 0.N |
|             |     |     |     |     |             |     |
Project и developer - составные объекты. У них атрибуты Manager, Developer, Project ссылаются на другие объекты.
#### Ассоциативный объект
А здесь всё весело, тем не мене весьма нужная фишка, когда у нас появляются объекты многие ко многим.

Ассоциативный объект представляет связь между другими объектами и хранит доп. инфу об этой связи. Как правило используется для связки многие ко многим.

##### As Is
Имеется 2 таблицы Project и Developer. 

| Project     |     |
| ----------- | --- |
| ProjectId   | 1.1 |
| Description | 1.1 |
| Manager     | 1.1 |
| Developer   | 1.N |

| Developer   |     |
| ----------- | --- |
| DeveloperId | 1.1 |
| FristName   | 1.1 |
| LastName    | 1.1 |
| Project     | 0.N |
В таблице Project засовывается вся инфа по проекту, включая работяг на нем. По умолчанию мы считаем, что у Project работают только Developer. У множества Developer может быть множество Project и наоборот. Если связь только этим ограничивается, то норм, однако если для этих связей нужна доп. информация, то в этой модели не найдется для нее места.

И если нам в таблице Project потребуется добавить кроме *Developer* еще и *Manager*, то информация доп. информация о Manager нигде не хранится.

Решение здесь - создать промежуточную таблицу - ассоциативный объект, который будет содержать в себе всю необходимую информацию нужную для связи многие ко многим.

##### To Be

| №1. Project  |                           |             |     | №2. ProjectRole |                    |                     |              |     | №3. Developer       |           |              |             |     |
| ------------ | ------------------------- | ----------- | --- | --------------- | ------------------ | ------------------- | ------------ | --- | ------------------- | --------- | ------------ | ----------- | --- |
| ProjectID    | 1.1                       |             |     | RoleID          | 1.1                |                     |              |     | DeveloperId         | 1.1       |              |             |     |
| Description  | 1.1                       |             |     | RoleName        | 1.1                |                     |              |     | FirstName           | 1.1       |              |             |     |
| ProjectRole  | 1.N                       |             |     | Developer       | 0.N                |                     |              |     | LastName            | 1.1       |              |             |     |
|              |                           |             |     | Project         | 0.N                |                     |              |     | ProjectRole         | 0.N       |              |             |     |
|              |                           |             |     |                 |                    |                     |              |     |                     |           |              |             |     |
|              |                           |             |     |                 |                    |                     |              |     |                     |           |              |             |     |
| Project      |                           |             |     | ProjectRole     |                    |                     |              |     | developer           |           |              |             |     |
| ProjectID    | Description               | ProjectRole |     | RoleID          | RoleName           | Developer           | Project      |     | DeveloperId         | FirstName | LastName     | ProjectRole |     |
| Собери друга | Собери друга из запчастей | Роль 1      |     | Роль 1          | Сумасшедший ученый | Доктор Франкенштейн | Собери друга |     | Доктор Франкенштейн | Тед       | Франкенштейн | Роль 1      |     |
|              |                           | Роль 2      |     | Роль 2          | Прислужник         | Игорь               | Собери друга |     | Игорь               | Игорь     | Джонсон      | Роль 2      |     |
|              |                           |             |     |                 |                    |                     |              |     |                     |           |              |             |     |
|              |                           |             |     |                 |                    |                     |              |     |                     |           |              |             |     |


Теперь мы не храним инфу о Manager и Developer в таблице Project. Вместо этого мы храним всю интересующую инфу в таблице Project_Role. Таким образом в Project_role у нас закидывается вся доп. инфа необходимая для связи многие ко многим. А из Project_Role уже связываемся с Developer.
Было Project - Developer
Стало Project - Project_Role - Developer
#### Наследуемые классы
Иногда один класс может иметь большинство характеристик другого класса, но с несколькими различиями.
Например класс Car обладает определенными характеристиками.

Класс *Гоночный автомобиль* наследует от класса Car, но обладает специфичными характеристиками.

|   |   |   |   |   |
|---|---|---|---|---|
|Car|||RaceCar||
|CarId|1.1||Car|p(доч-й объект)|
|Make|1.1||ZeroTo60Time|1.1|
|Model|1.1||TopSpeed|1.1|
|Year|1.1||||
|RaceCar|0.ST||||
### ER диаграмма
Расширение Семантической объектной модели, где уже работаем максимально приближенно к реляционным таблицам.