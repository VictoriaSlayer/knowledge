Главенствует принцип что посеешь, то и пожнешь. Плохое проектирование аффектит на результативность всей системы.

База данных - инструмент хранящий данные и позволяющий их CRUD тем или иным способом.
# Желательные функции БД
## 1. CRUD
## 2. Извлечение
Извлечение - retrieval, аналог READ. Возможность быстро и надежно находить каждый фрагмент данных различными способоми.
## 3. Согласованность
Другой аспект READ. БД должна выдавать согласованные результаты.
С согласованностью куча вытекающих причин, следствий и вопросов как это нормально делать:
- БД не должна быть спроектирована так, что в разных ее частях хранятся непротиворечивые данные - например контактные данные;
- два последовательных запроса пользователя должны выкидывать один результат в случае если не случилась транзакция;
- один и тот же запрос должен выдавать одни и те же результаты;
## 4. Валидность
Тесно связанна с концепцией согласованности. Различные части данных должны содержать непротиворечивые сведения относительно одной и той же информации. Там, где возможно данные проверяются в сравнении с другими фрагментами данных имеющимися в базе. В CRUD валидность может быть проверена при Create, Update, Delete.
Валидность связана с:
- проверка допустимых значений;
- непротиворечивость данных в разных её частях;
- ограничения которые можно задать на уровне логики (приложению, БД и т.д., например если у нас максимально 500 шт. пользователь не может заказать больше 500 и именно из этой точки);
## 5. Простое исправление ошибок
Без комментариев
## 6. Скорость
Быстрота всех аспектов CRUD. На примере бюджетного комитета.
## 7. Атомарные транзакции
Атомарная транзакция - сложная цепочка действий рассматриваемая как единая. Транзакция проходит целиком, либо не проходит вообще.
Пример - при переводе денег с одного счета на другой, никто не может увидеть базу данных, пока она находится в промежуточном состоянии
### 7.1 ACID - свойства атомарных транзакций 
*Atomicity* (атомарность) - транзакции атомарны. Операции либо происходят все, либо не происходят вовсе.
*Consistency* (согласованность) - транзакция гарантирует, что БД до и после находится в согласованном состоянии. Если транзакция нарушит правила БД, то транзакция откатится. 
Пример - если у нас на счет 100к, то мы не можем послать 150к.
*Isolation* (изолированность) - транзакция изолирует детали операции от всех людей, кроме человека её совершившего.
У двух клиентов по 100к, при переводе 100к от одного клиента к другому нам необходимо проверить счета обоих клиентов. Мы увидим либо 100 и 100, либо 0 и 200. 
*Durability* (долговечность) - транзакция не исчезнет после совершения операции.
## 8. BASE - NoSQL
NoSQL накладывают определенные ограничения на архитектуру БД и принципы ACID к ним неприменимы. Чтобы лучше соответствовать асинхронному, распределенному, облачному характеру работы используют принципы BASE.
Basically Available - базовая доступность. Данные доступны, если данные нельзя получить, то это не БД. NoSQL распространяет свои данные по всем кластерам БД, поэтому данные не могут быть сразу согласованны.
Soft state - неустойчивое состояние. Означает, что с течением времени состояние данных может меняться. NoSQL не требуют моментальной согласованности, поэтому нужно время, чтобы данные стали согласованны. NoSQL полагают, что разработчик обеспечит согласованность данных.
Eventually consistent - согласованность в конечном счете. БД становятся согласованны в конечном счете.

### NewSQL
Парадигма пытающаяся объединить ACID и BASE.
## 9. Постоянное и резервное копирование
Резервное копирование раз в сутки - 1С Бит.
Постоянное копирование - фондовая биржа.
## 10. Низкая стоимость и расширяемость
Под расширяемостью имеется ввиду новые БД необходимые в рамках развития продукта.
## 11. Простота использования
GUI
## 12. Переносимость
Перенос БД из одной среды в другую (регион, страна).
## 13. Безопасность
Доступ к данным.
Перехват данных.
Хранение данных.
## 14. Совместное использование
Ролевая модель доступа к данным.
## 15. Теорема САР
Consistensy - согласованность. При каждом считывании выводятся последние записанные данные.
Availability - доступность. При считывании выдается ошибка, если вы не гарантируете, что будут выданы последние записанные данные.
Partition - устойчивость к разделению. DWH продолжает работать, даже если сообщения отбрасываются или задерживаются при передаче между разделами. 
Можно добиться 2 из 3, но не более.
Жертвовать С и А нужно только в том случае, если DWH разбито на разделы. Если данные хранятся в одном месте, то можно добиться согласованности и доступности.

# SQL полное руководство
## Целостность данных
Согласованность и целостность часто суть одни и те же понятия обеспечивающие непротиворечивость и правильность хранимой информации:
- обязательное наличие данных;
- условие на значение;
- логическая целостность данных;
- ссылочная целостность данных;
- другие отношения между данными (моделируемая БД ситуация реального мира накладывает ограничения);
- бизнес-правила;
- непротиворечивость;

![[Pasted image 20250901075823.png]]
Отношения предок-потомок
### Ссылочная целостность
Существуют 4 типа изменений базы данных, которые могут нарушить ссылочную целостность предок-потомок:
- **Добавление новой дочерней строки**. Когда происходит добавление новой строки в дочернюю таблицу (SALESREPS), значение ее внешнего ключа (REP_OFF I CE) должно быть равно одному из значений первичного ключа (OF F I CE) в родительской таблице (OF F I CES). Если значение внешнего ключа не равно ни одному из значений первичного ключа, то добавление такой строки повредит базу данных, поскольку в ней появится потомок без предка ("сирота"). Обратите внимание на то, что добавление строки в родительскую таблицу проблем никогда не вызывает – она просто становится предком без потомков.

- **Обновление внешнего ключа в дочерней строке**. Это та же проблема, что и в предыдущей ситуации, но выраженная в иной форме. Если внешний ключ (REP_OFFI CE) обновляется инструкцией UPDATE, то его новое значение должно быть равно одному из значений первичного ключа (OF F I CE) в родительской таблице (OFF I CES). В противном случае обновленная строка окажется "сиротой".

- **Удаление родительской строки**. Если из родительской таблицы (OF F I CES) будет удалена строка, у которой есть хотя бы один потомок (в таблице SALESRE PS), то дочерние строки станут "сиротами". Значения внешних ключей (REP_OFFI CE) в этих строках больше не будут равны ни одному из значений первичного ключа (OFFI CE) родительской таблицы. Обратите внимание на то, что удаление строки из дочерней таблицы никогда не вызывает проблем - просто предок этой строки после удаления будет иметь на одного потомка меньше.
- **Обновление первичного ключа в родительской строке**. Это иная форма проблемы, рассмотренной в предыдущем пункте. Если происходит изменение первичного ключа (OFF I CE) некоторой строки в родительской таблице (OFF I CES), все существующие потомки этой строки становятся "сиротами", поскольку их внешние ключи больше не равны ни одному первичному ключу.
#### Решение проблем
Если необходимо, то там же смотри решения.
Для примера - могут быть каскадные удаления строк по связанным таблицам, но если мы встречаемся с ситуацией, когда все таблицы по кругу со всеми связаны, то это может привести к удалению всех таблиц. 
Поэтому в зависимости от ситуации было бы удобно, если бы условия ссылочной целостности не проверялись до определенного момента.
### Constraint
Ограничения на первичные и внешние ключи, условия уникальности столбцов, ограничения на отсутствующие значения представляют достаточно специализированные способы обеспечения целостности данных:
- ограничения столбцов - концептуально ограничивают допустимые значения;
- домены - особая форма ограничений столбца. С их помощью можно создавать нечто наподобие новых типов данных, используемых в конкретной БД. Домен по сути один из предопределенных типов данных, на который наложены некоторые доп. ограничения являющиеся частью домена;
- ограничения таблиц - задаются как часть определения таблицы при её создании. Ограничивают значения, которые могут присутствовать в строках таблицы;
- утверждения - наиболее общий тип ограничений, создаются для проверок утверждений
  ![[Pasted image 20250901083249.png]]
#### Отложенная проверка ограничений
Гарантировать, что *плановый объем продаж офиса* = *сумме плановых объемов продаж его служащих*.
В итоге мы не можем проверить таблицу по плановым объемам продаж офиса пока у нас не будет информация по продажам каждого члена этого офиса.
В этом случае у SQL можно создать Constraint с атрибутом:
- DEFERRABLE - проверка не будет проведена пока не будет завершена транзакция;
- NOT DEFERRABLE - проверка не может быть отложена (используется по умолчанию, т.к. более жесткая проверка);
### Бизнес-правила
В реальной жизни вопрос целостности данных часто бывает связан с порядками и правилами, установленным в конкретных организациях:
- клиенту не разрешается размещать заказы на сумму превышающую предел их кредита;
- если клиенту выдали заказ на сумму больше 500000$, то необходимо уведомить вице-президента и т.д.;
Реализация бизнес-правил на бэк уровне имеет ряд недостатков:
- дублирование - если шесть разных программ осуществляют различные изменения в таблице, то каждая должна соблюдать бизнес-правила;
- недостаточная согласованность - велика вероятность, что поддержка бизнес-правил программами будет осуществляться по своему;
- трудности сопровождения;
- сложность - при большом количестве бизнес правил;

Из-за всего этого появились триггеры - с любым событием вызывающим изменение содержимого таблицы, пользователь может связать сопутствующее действие, которое СУБД должна выполнять при каждом возникновении события. Например триггеры запускающие INSERT, DELETE, UPDATE.
Пример
![[Pasted image 20250901223335.png]]
Триггер вызывается каждый раз, когда к таблице ORDERS обращается инструкция INSERT.
В оставшейся части определения (после ключевого слова AS) описывается действие, выполняемое триггером. В данном случае это действие представляет собой последовательность двух инструкций UPDATE: одна для таблицы SALESREPS, а другая для таблицы PRODUCTS. 