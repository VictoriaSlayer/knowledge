# Курсоры
Используют для построчного чтения имеющихся строк через циклы. 13 урок начало.
Применения не увидел, автор также говорит, что применение весьма специфично, поэтому не конспектировал.
# Хранимые процедуры
Хранимые процедуры - именованный набор операторов хранящийся на сервере. Блок кода, в который мы будем помещать другие операторы, управляющие инструкции. Хранимая процедура блок кода являющийся объектом, который физически хранится на сервере.

Преимущества:
- повышение производительности. При выполнении процедуры в первый раз она компилируется, определяя оптимальный маршрут получения данных. Если в кэше есть план выполнения, то процедура будет выполняться быстрее, так как серверу не придется разбирать запрос и вырабатывать необходимые действия для решения поставленной задачи. Изменения в БД могут изменить план выполнения, делая его неэффективным и недействительным. Сервер определяет эти изменения автоматически и компилирует маршрут.
- уменьшение сетевого трафика. Пользователи выполняют только один запрос, что уменьшает количество запросов между клиентом и сервером. Мы множество строк кода вызываем на клиенте, а не на сервере;
- повторное использование кода. Используем один и тот же код в разных задачах, а не пишем его заново;
- безопасность. Пользователи могут получить право выполнять процедуры, даже если у них нет права на использование таблицы или представления на которые ссылается код;

## Пример создания
Create procedure spGetAllPlayers
-- либо альтернативное слово PROC
-- название процедуры рекомендуется начинать с sp
-- но не с sp_ т.к. sp_ системная процедура и будет конфликт.
as
SELECT * FROM Players
go

-- Процедура для нас черный ящик, что там дальше происходит нас не особо волнует

-- Вызвать процедуру
exec spGetAllPlayers
-- либо полное слово execute (exec sp_help, spGetAllPlayers и т.д.)

Для выборок чаще используются вьюхи, для вставки и обновления данных - процедуры.
![[Pasted image 20240908182724.png]]
Место хранения процедуры.
Процедуры могут принимать параметры, но они не возвращают значения. 

exec spProcedure where id = 1
-- ТАК РАБОТАТЬ НЕ БУДЕТ, строго ранее заданный код.

Процедуру можно вызвать и без ключевого слова exec. Просто название процедуры. Главное, чтобы вызов шел в разных пакетах. 
execute spProc
go
spProc
-- так сработает, потому что есть go, без него бы не работало.

В процедуре мы можем выполнять сколько угодно Select, использовать условные конструкции.

## Изменить процедуру
ALTER PROC spPlayers
as
select * from players
select * from playerstats

## Скрыть часть полей от пользователя
Особенность примера в том, что если мы хотим для пользователя скрыть какие либо поле,
но хотим по нему фильтроваться, то можно сделать процедуру.
Процедура инкапсулирует в себе это поле

Create proc spGetPlayers
	@BirthDate date
as
	SET NOCOUNT ON
	-- в результирующем запросе не выводит количество строк которые были обработаны в результате выполнения
	Select p.id, p.Fname, p.Lname from players p
	join PlayerInfos Pi
	on p.id = pi.Playerid 
	where pi.birthdate > @birthdate
	-- поле birthdate скрыто
	-- выводятся только те игроки у которых дата рождения больше объявленного @birthdate

Мы не сможем вызвать эту процедуру без аргументов. Она принимает аргумент birthdate:
exec spGetPlayers '19900101'
-- а вот смотри Святослав и вспоминай логику, игроков какого возраста они тут выводят

### Не передавать процедуре дефолтные значения
Под дефолтным значением подразумеваем значение заданное по умолчанию:
Alter Proc spGetPlayers
@birthdate date = '19900101'
as

SET NOCOUNT ON
Select p.id, p.Fname, p.Lname from players p
	join PlayerInfos Pi
	on p.id = pi.Playerid 
	where pi.birthdate > @birthdate


Для добавления дефолтного параметра пришлось перепрописывать весь код процедуры заново.
Теперь эту процедуру можно вызвать без аргумента
exec spGetPlayers

### Искать по определенным аргументам
	--wildcard parameters
ALTER PROC spGetPlayers
	@FName varchar(50) = N'%',
	@LName varchar(50) = N'%'
	-- создаем процедуру с аргументами, которые могут принимать любое количество символов
AS
	SET NOCOUNT ON
	SELECT p.Id, p.FName, p.LName, pi.BirthDate, pi.Country FROM Players p
			JOIN PlayerInfos pi ON p.Id = pi.PlayerId
			WHERE p.FName LIKE @FName AND p.LName LIKE @LName;
	-- если мы не передаем никакие аргументы, то fname, lname может быть любым
GO

EXEC spGetPlayers @LName = 'M%'
EXEC spGetPlayers 'Andy', 'Murray'
-- либо ищем по определенным аргументам которые передали
EXEC spGetPlayers 'M%'
-- ищет по первому аргументу

### OUT/OUTPUT
27-32 минуты.
Out и output одно и то же.
Из процедуры можно вернуть значение не через return, а через out/output. Но логика в том, что ты можешь вернуть значение только если как-то изменяешь аргумент который передаешь. Таким образом это ограничение.

команда возвращает значение из процедуры

--OUT, OUTPUT
ALTER PROC spGetPlayers
	@Id int,
	@Rank int OUT
AS
	SET NOCOUNT ON
	SET @Rank = (SELECT TOP 1 Rank FROM Players
-- в процедуре задали команду Set, которая делает вычисление
-- мы делаем вычисление через TOP 1 - вычисляемое значение которое передали
-- то есть если мы постоянно будем передавать top 1, то будем получать одно и то же
			WHERE Id = @Id);
	--RETURN -1
GO

DECLARE @R int;
EXEC spGetPlayerRank 1, @R OUTPUT
-- вызвали процедуру с аргументами 1 и переменной R которую просим вывести
PRINT @R

## Создать процедуру которая будет добавлять новое значение в таблицу

CREATE PROC spAddPlayer
	@FName varchar(50) = NULL,
	@LName varchar(50),
	@Rank int = NULL,
	@BirthDate date = NULL,
	@Weight smallint = NULL,
	@Height smallint = NULL,
	@Country varchar(50) = NULL,
	@BirthPlace varchar(50) = NULL,
	@Residence varchar(50) = NULL
-- Создали процедуру с аргументами, которая принимает дефолтные значения
AS
	SET NOCOUNT ON;
	DECLARE @Id int;
-- в теле процедуры объявили переменную ID, то есть каждый раз когда будет вызываться процедура, она будет создаваться

INSERT Players VALUES
(@FName, @LName, @Rank)
-- вставляем в таблицу Players значения, которые передаем в процедуру

SET @Id = @@IDENTITY
-- с помощью функции @@Identity получаем Id вставленного игрока, записываем его в переменную

INSERT PlayerInfos VALUES
(@Id, @BirthDate, @Weight, @Height, @Country, @BirthPlace, @Residence)
-- вставляем в таблицу playerinfos остальные данные
GO

EXEC spAddPlayer @LName = 'Dolgopolov', @Country = 'Ukraine'
-- запустили записанную выше процедуру 

## Обновлять данные при помощи процедуры
Кейс - необходимо во всех таблицах поменять минимальную зарплату, т.к. увеличился прожиточный минимум.

Создаем процедуру:

Create proc spUpdateMinSalary
@MinSalary decimal(9, 4),
as
set nocount on;
update salaries
set Rate = @MinSalary
where Rate < @MinSalary
Go

exec spUpdateMinSalary 1700

![[Pasted image 20240913195314.png]]

# Функции
Функции обладают теми же преимуществами, что и процедуры.
Но между хранимыми процедурами и пользовательскими функциями есть ряд отличий. Подробнее об отличиях - надо читать доку:
https://blogs.msdn.microsoft.com/pradeepsvs/2014/10/08/difference-between-a-stored-procedure-and-function/

Мы не можем использовать DML.
Мы можем селектить, но селектим в переменную которая потом возвращается или инсертим в переменную табличного типа, которая потом так же будет возвращаться.

Мы не можем использовать в функции Insert, Update, Delete.

### Пример №1
Функция принимает айди игрока и возвращает среднее количество эйсов для этого игрока.

Create FUNCTION fnGetPlayerAverageAces (@playerId int)
-- название функции, желательно начинать с fn
-- в скобках название аргумента который передаем и его тип
returns int
-- именно returnS и тип возвращаемого значения
as
-- после ключевого слово AS идет тело функции
begin
-- тело функции заключаем в конструкцию begin ... end
declare @avgAces int
set @avgAces = (select avg(aces) from playerstats where playerid = @playerId)
-- записываем в переменную значения через селект
return @avgAces
-- возвращаем переменную через returN
end

Функции бывают скалярные(int, string и т.д.) и табличные (table).
Функции бывают детерминированные и недетерминированные.
Детерминированные - возвращают одни и те же значения.
Недетерминированные - разные. Например генератор случайных чисел.

Расположение функций
![[Pasted image 20240913201623.png]]
Функции можем использовать в селектах, джойнах, в отличии от процедур.
Вызвать функцию:
print dbo.fnGetPlayerAvgAces(5)
dbo. - приставка обязательна, иначе будет ошибка. Рекомендуется указывать полностью все таблицы, так MS SQL быстрее искать.

Select fName, lName, dbo.fnGetPlayerAverageAces(id) avgAces from Players
в качестве аргумента мы передаем столбец id из таблицы Players

### Пример №2
Функция возвращающая таблицу. В данном случае функция используется как аналог вьюх.

Create Function fnGetPlayersMatches()
returns table
as
return
(
	SELECT t.Name Tournament, c.Name Court, m1.Date, m1.Time, p1.FName + ' ' + p1.LName Winner, p2.FName + ' ' + p2.LName Loser
	FROM Matches m1
	JOIN Tournaments t 
		ON t.Id = m1.TournamentId
	JOIN PlayerStats ps1
		ON m1.Id = ps1.MatchId AND ps1.Win = 1
	JOIN PlayerStats ps2
		ON m1.Id = ps2.MatchId AND ps2.Win = 0
	JOIN Players p1 
		ON p1.Id = ps1.PlayerId
	JOIN Players p2
		ON p2.Id = ps2.PlayerId
	JOIN Courts c ON c.Id = m1.CourtId
)
go

select * from dbo.fnGetPlayersMatches();
-- вызвать функцию
Если мы не хотим передавать в функцию аргумент, передаем туда ключевое слово DEFAULT
select * from dbo.fnGetPlayersMatches(DEFAULT);

Во вьюху мы можем инсертить, вьюху мы можем проапдейтить. Функция может принимать аргументы и мы можем что-то инкапсулировать. 