Select
	All* - все строки по умолчанию
	Distinct - только уникальные значения без дубликатов
	Top * - первые строки, количество задается числом или процентами
From <Table>

with ties - может использоваться только в паре с ORDER BY. Указывает на то, что будут возвращены дополнительные строки из основного результирующего набора с тем же значением Order By, которые появляются как последний из TOP n (percent) строк. Предложение Top... with ties может быть задано только в инструкциях SELECT и только если указано предложение Order BY.

Order By - используем для сортировки строк

### Логический порядок обработки инструкции SELECT

Определенный порядок слов, по которому можем делать запрос.
Согласно этому порядку предложения последующих стадий получают доступ к объектам, определенным на предыдущей стадии. Поскольку стадия предложения Select - 8, то любые псевдонимы столбцов или производные столбцы, определенные в этом предложении, не могут упоминаться в предыдущих предложениях.

1. From
2. On
3. Join
4. Where
5. Group By
6. With Cube и With Rollup
7. Having
8. Select
9. Distinct
10. Order By
11. Top


Distinct - выбор уникальных значений

Top - выбор заданного числа

### Выбрать

#### Выбрать уникальные значения в столбце
select distinct [имя_столбца] from [имя_таблицы]

#### Выбрать 10 первых строчек из таблицы
select top 10 * from [имя_таблицы]

#### Выбрать 10 строчек из определенного столбца
select top 10 [имя_столбца] from [имя_таблицы]

#### Выбрать проценты
select top 25 percent * from [имя_таблицы]

### Сортировка строк

#### Сортировка по одному столбцу
select top 10 [имя_столбца] from [имя_таблицы]
order by [имя_столбца]

#### Сортировка одного столбца в рамках другого
select top 10 [имя_столбца] from [имя_таблицы]
order by [имя_столбца_1], [имя_столбца_2]


#### Изменить порядок сортировки
По умолчанию сортировка идет в режиме Asc (Ascending).
Поменять на противоположный Desc (Descending).

#### Сортировать по номерам столбцов
Не рекомендуется делать, т.к. ненаглядно

select top 10 [имя_столбца] from [имя_таблицы]
order by [№столбца], [№столбца]


### With ties
Для включения строк, соответствующих значениям в последней строке. 
Грубо говоря, выбираем первые 30 строк. У последней строки значение ZXC. With ties добавляет к этим 30 строкам, все оставшиеся строки (допустим 4), у которых значение также ZXC.

Select Top 30 with ties Fname, Lname from MyTable
Order by Salary Desc

#### Select ... into ...
Скопировать выбранные данные в таблицу. Будет создана новая таблица.
Select Id, FName, LName, Salary
into [имя_новой_таблицы]
from [имя_старой_таблицы]

### WHERE
Оператор условия выборки
Select * From [имя_таблицы]
where [имя_столбца] [оператор_сравнения] [условие]

Select * From [имя_таблицы]
where Department = 'sales'

Операторы сравнения
=
'<>' или != (не равно)
'>'
'<'
'>='
'<='
'!<' - не меньше
'!>' - не больше

Select * from MyTable
where Birthdaydate > '19900101'

По сути оператор Where работает через проверку булево значения True или False. В самих столбцах мы не можем хранить булево значение True/False.
В Sql булево может принимать 3 значения True/False/Unknown.

#### Логические операторы для WHERE
Часто используемые:
AND
OR
NOT

Реже:
Like
Between
All
In
Some/any (одно и то же)
Exists

  Select * from myTable
  where Department = 'Finances' and Salary > 7
  
#### Выбрать несколько значений
Select *from myTable
where salary > 7 and (department = 'Payroll' or department = 'Finances')

ВНИмАНиЕ!!! необходимо принимать во внимание приоритет операндов и действия в скобках

#### Выбрать несколько значений
Select * from [имя_таблицы]
Where [имя_столбца] in ('значение', 'значение', 'значение')

#### Нахождение строк содержащих значение между двумя значениями
№1
Select * from [имя_таблицы]
Where [имя_столбца] БОЛЬШЕ [значение1] and [имя_столбца] МЕНЬШЕ [значение2]

№2
Select * from [имя_таблицы]
Where [имя_столбца] BETWEEN [значение1] and [значение2]

### Like - нахождение строк, содержащих значение как часть строки

Для использования оператора Like зачастую используются подстановочные символы

#### %
% - любое количество любых символов;
select * from [имя_таблицы]
where department like 'ad%'

или
where department like '%ad' - поиск заканчивается на символы ad

#### _
_ - один любой символ;
Любой второй символ равен двойке
select * from [имя_таблицы]
where department like '_2' - поиск в строке заканчивается на 2

Любой третий символ равен двойке
select * from [имя_таблицы]
where department like '__2'

Любой символ равен "e"
select * from myTable
where department like '%e'

#### []
[] - какие конкретно символы;
интересует двойка, следующий символ любой

select * from [имя_таблицы]
where id '[2]%следующий_символ%'

интересует двойка или четверка, следующий символ любой
select * from [имя_таблицы]
where id '[2, 4]%следующий_символ%'

интересуют буквенные символы от A до C и окончание фразы любое
select * from myTable
where department like '[C, A]%'

интересуют буквенные символы от C до P и окончание фразы arsen
`WHERE au_lname LIKE '[C-P]arsen'` 

#### [^]
[^] не равно

интересуют столбцы, где первый символ не 2 и не 4

select * from [имя_таблицы]
where id '[^2, 4]'


### NULL
В Sql нельзя NULL сравнивать с оператором "="

!!! Так не сработает !!!
select * myTable
where Salary = NULL

для сравнения с NULL используется IS
select * myTable
where Salary IS NULL

#### NOT
для сравнения с НЕ РАВНО NULL используется NOT

select * from myTable
where Salary IS NOT NULL


#### Ошибки при выборке с NULL

ТАК Система не покажет NULL значения даже если они есть
select * from myTable
where Salary in (4000, 7000, NULL)

НАДО
select * from myTable
where Salary in (4000, 7000)
OR Salary is NULL


### CASE
CASE - грубо говоря позволяет классифицировать значения в отдельных столбцах, так сказать группировать их.
По сути конструкция SwitchCase из ЯП.
По хорошему необходимо смотреть на работу функции.

### IIF
По сути элегантная замена CASE
IIF это функция
IIF(условие, ИСТИНА, ЛОЖЬ) AS [название_столбца]

Пример
select Fname, Lname, 
IIF(salary >= 15, 'GOOD', 'BAD') as [Имя_выводимого_столбца]
from [имя_таблицы]


GROUP BY

