# Общие вводные

Подзапрос/вложенный запрос - запрос, помещаемый в другой запрос или инструкцию SELECT, INSERT, UPDATE, DELETE. Подзапрос разрешен везде, где разрешены выражения.
Основный запрос - внешний запрос.
Подзапрос - внутренний запрос или запрос операции выбора.
Разрешено до 32 уровней вложенности.
![[Pasted image 20240824172745.png]]
Подзапросы бывают независимые и связанные.
Если подзапрос возвращает таблицу, то эту таблицу можно назвать производной таблицей.
 
Подзапросы можно использовать с операторами равенства, IN, ALL, ANY, EXIST.

Подзапросы удобнее JOIN когда необходимо вычислить агрегатное значение.

  select * from players
  where id in (
  select id from playerinfos where height = (select max (height) from PlayerInfos)
  )
# ALL, ANY, EXIST
## ALL
Команда ALL проверяет на равенство со всеми значениями из списка.

  select * from players
  where id != all 
  -- поле id не равно ни одному из значений полученных в выражении
  (
  select * from matches m
  join playerstats pl
  on m.id = pl.id
  where m.round = 'finals'
  )
## Exists
Если выражение возвращает какие-то строки то Exist возвращает True. Если нет, то False.
![[Pasted image 20240826230612.png]]
## Any
Возвращает любые значения из массива
select * from Courts
where id = ANY (select CourtId from Matches)

# Связанные подзапросы
Подзапросы которые связаны с внешними запросами.
Необходимо:
- Выбрать строку из таблицы, указанной во внешнем запросе. Это будет текущая строка кандидат;
- СОхранить значения из этой строки-кандидата во временном буфере;
- Выполнить подзапрос. ДЛя отбора записей использовать строку-кандидат;
- Вычислить условие внешнем запросе, на основе результатов внутреннего подзапроса, выполняемого в 3-м пункте. Определить отбирается ли строка-кандидат для вывода;
- Повторить процедуру для всех строк;
Объяснение в целом корявое, автор рекомендует практику. Собственно говоря сам пример:
  select * from playerstats ps1
  where aces = (select max(aces) from playerstats ps2 where ps1.playerId = ps2.playerId)

## Когда использовать Join, когда подзапросы?
В случае если у нас в столбце идёт вычисляемое значение, то тогда используем подзапросы.
В случае если нам надо просто объединить таблицы, то используем Join, так как это быстрее.
В случае подзапросов приходится делать вычисления в каждой генерящейся строчке.
select lname,
(select max(aces) from playerstats ps where ps.playerid=p.id)
from players p

## APPLY
Укорачивание одинаковых вычисляемых подзапросов. Вместо того, чтобы писать длинный код c повторяющимися подзапросами:
Select Lname,
(Select Min(aces) from playerstats ps where ps.playerid = p.id) Min_Aces,
(Select Max(aces) from playerstats ps where ps.playerid = p.id) Max_Aces,
from players p

Select Lname,
psa.min_aces, psa.max_aces
from players p
CROSS APPLY
(select max(aces) Max_Aces, min(aces) Min_Aces from playerstats ps where ps.playerid = p.id) psa

В последнем варианте будет выполняться один подзапрос вместо двух.

# Временные таблицы
Временные таблицы отличаются от постоянных тем, что хранятся в папке БД tempdb и автоматически удаляются, когда необходимость в них отпадает.
Бывают локальные и глобальные временные таблицы. Они отличаются друг от друга именами, видимостью и доступностью.
Имена локальны временных таблиц начинаются с символа (#). Они видны только текущему соединению пользователя и удаляются, когда пользователь отключается от экземпляра SQL Server. Имена глобальных таблиц начинаются с двух (##). Они видны любому пользователю и удаляются, когда все пользователи, которые на них ссылаются, отключаются от экземпляра SQL Server.
Локальная временная таблица, созданная хранимой процедурой удаляется автоматически при завершении хранимой процедуры.

## Табличная переменная
Табличная переменная используется как альтернатива временным таблицам. Она работает только в рамках того пакета, который мы указали. 
declare @myTableVar table (
ID int,
name varchar (30),
rank int
)

insert into @myTableVar
Select top 5 id, lname, Rank from Players
Where Rank Is not Null
Order By Rank

Если пакеты будут разбиты при помощи команды GO, то нам будет выбивать ошибку, что такой таблицы не существует.
![[Pasted image 20240903000259.png]]

## Временная таблица
Хранится не в БД в которой мы работаем в отличии от временной таблицы, а в папке System Databases => tempdb =>temporary tables
Когда мы создали временную таблицу, мы к ней можем обращаться сколько угодно раз, пока не отключились от сервера.
![[Pasted image 20240903000913.png]]
Временная таблица будет удаляться, когда пользователь отключается от сервера и эти таблицы видны только этому пользователю.
![[Pasted image 20240903001257.png]]

Рекомендуется явно удалять временные таблицы при помощи команды Drop Table. 

# Обобщенные табличные выражения
ОТВ - временные результатирующие наборы, определенные в области выполнения единичных инструкций SELECT, INSERT, UPDATE. ОТВ как и производные таблицы не сохраняются в БД в виде объектов, время их жизни ограничено продолжительностью запроса.
Применение ОТВ позволяет значительно повысить читаемость и упростить работу со сложными запросами, разбив его на отдельные логические строительные блоки. Из них можно составлять более сложные промежуточные ОТВ для формирования конечного результирующего набора.
ОТВ могут быть определены в пользовательских подпрограммах (функциях, хранимых процедурах, триггерах, представлениях).

ОТВ это аналог подзапросов. Что лучше использовать - это дело вкуса.

![[Pasted image 20240903002132.png]]
Players_CTE - название ОТВ.
Команды With и As используются здесь в другом контексте.
ОТВ создается только на время пакета в оперативной памяти и тут же удаляется, если мы потом селектнемся, то будет ошибка, т.к. пакета этого нет.