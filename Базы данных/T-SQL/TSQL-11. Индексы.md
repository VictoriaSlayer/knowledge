(про кластеры) [[БД от ВК 1. Введение]]

# Индекс
Индексы - структура на диске, которая связана с таблицей или представлением и ускоряет получение строк из таблицы или представления. Индекс содержит ключи, построенные из одного или нескольких столбцов в таблице. Эти ключи хранятся в виде структуры сбалансированного дерева.
В тоже время индекс занимает дополнительное место в памяти и может иметь обратный эффект - не повышение, а понижение производительности.

Индекс такой же объект, как таблица. Индексы вешают на столбцы или представления. По своей сути индекс это ключ организованный в виде структуры сбалансированного дерева. За счет организации индексов по структуре ускоряется поиск данных в одних случаях.
Чтобы понимать как хранят индексы, надо в начале понимать устройство страниц и экстентов.
 
 # Страницы и экстенты 
 Основной единицей хранения данных в SQL Server является страница. Размер страницы составляет 8КБ. Каждая страница начинается с 96-байтового заголовка, который используется для хранения системных данных о странице:
 - номер страницы;
 - тип страницы;
 - объем свободного места на странице и идентификатор объекта;
 - идентификатор объекта, которому принадлежит страница;
![[Pasted image 20240903223203.png]]
Типы страниц:
- страницы данных (кроме больших типов данных типа varchar, varbinary и т.д.);
- страницы индексов;
- страницы текста/изображения (для данных типа varchar, varbinary и т.д.);
- Index Allocation Map;
- Прочие;

8 страниц объединяются в экстент. Экстент основная единица хранения данных (организации пространства). Содержит в себе 8 непрерывных страниц. 
Экстенты бывают смешанные и однородные.
Каждая из восьми страниц в смешанном экстенте находится во владении разных объектов.
Однородные экстенты принадлежат одному объекту; Все восемь страниц в кластере могут быть использованы только этим владеющим объектом.

![[Pasted image 20240903223717.png]]
В этом слайде подразумеваются не таблицы, а страницы хранящие данные.
## Куча
![[Pasted image 20240903223820.png]]
## Индекс
![[Pasted image 20240903224114.png]]
Индексы бывают кластерные и некластерные. Кластерные более менее понятно. Некластерные какая-то шляпа.

Короче деревья неразрывно связаны с алгоритмами, они бывают разные.
На скрине вариант сбалансированного дерева. У дерева слева находится меньшее значение, а справа большее. Таким образом и ищут необходимое число. (Например 13).
У дерева всегда один root, далее идут промежуточные узлы и в конце листовые узлы.
В зависимости от типа индекса в конце поисков могут храниться как интересующие нас данные, так и переход к этим данным.
### Кластерный индекс
Индекс является таблицей. На уровне индекса мы храним данные. 
Кластерный индекс хранит реальные строки данных в листьях индекса. Важной характеристикой кластерного индекса является то, что все значения отсортированы в определенном порядке (возрастание или убывание). Таким образом таблица или представление может иметь только один кластерный индекс.
В SQL Server кластерный индекс является уникальным индексом по определению. Если существуют записи с одинаковыми значениями, SQL Server делает их уникальными добавляя номера(суффиксы) из внутреннего (невидимого снаружи) счетчика.

![[Pasted image 20240903225739.png]]
Как это работает:
![[Pasted image 20240903230445.png]]
В случае одинаковых значений будут добавляться суффиксы, чтобы различать значения.

![[Pasted image 20240903231636.png]]

### Некластерный индекс
Не очень то и внятно объяснил, не развернуто, такое ощущение, что часть информации упущена для понимания.

Некластерный индекс на листовом уровне содержит отсортированные значения индексированного столбца без данных и row locator - указатель на остальные данные. Если у таблицы есть кластерный индекс (кластерная таблица), то row locatorом является ключ кластерного индекса, если кластерного индекса нет (таблица-куча), то row locator - это row id (указатель на определенную строку данных в определенной таблице).
Некластерных индексов может быть множество. Кластерный индекс может быть только один.
Необходимо создавать кластерные ключи как можно более короткими. Кажджый некластерный индекс будет использовать значения кластерного индекса (если последний определен). Следовательно увеличение размера кластерного индекса приводит к увеличению занимаемой памяти для всех не кластерных индексов.
Необходимо создавать кластерный индекс первым, так как если уже будут некластерные индексы, то всем им нужно будет перестроиться - на листовом уровне вместо row Id указателем, на остальные данные должен стать ключ кластерного индекса.

![[Pasted image 20240903233029.png]]
Некластерный индекс на куче.
![[Pasted image 20240903233225.png]]
На листовом уровне хранит Row Id указатель с данными.

![[Pasted image 20240903233321.png]]
Cole оставшаяся информация хранится в кластерном индексе - 52. И уже по нему ищем остальные данные.
## Создание индексов
Primary Key по умолчанию создает уникальный кластерный индекс, но можно создать первичный ключ, который задаст некластерный индекс. Если у таблицы уже есть кластерный индекс, то создается некластерный индекс.

Create Table Persons (
	Id integer Primary Key,
	Name VARCHAR (255)
);

CREATE TABLE Persons (
Id INTEGER PRIMARY KEY NONCLUSTERED,
Name VARCHAR (255)
)

Индексы могут быть неуникальным в том случае если они некластерные. Но благодаря суффиксам система их между собой различает.

 Показать план выполнения запроса
 ![[Pasted image 20240906234740.png]]
 