В библиотеке Python имеются модули в которых уже реализована часть методов необходимых разработчикам для работы. Импортируя методы и зная функции которые нам нужны можем забирать то, что нам нужно не разрабатывая функции самим.
В Python все является объектом. Любая структура данных является объектом к которому допустимы свои методы:
- ['a', 'b', 'c'] - список, динамическая изменяемая структура;
- {'a': 'a'} - словарь, динамическая изменяемая;
- {'a', 'b', 'c'} - множество, каждое значение уникально;
- ('a', 'b', 'c') - кортеж, значения неизменяемые;

Служебные переменные _ _ имя переменной _ _
## Мелкие заметки по ходу книги
```python
# Множества
x = set('abc') - преобразование во множество
y = {'x', 'y', 'a'} - множество
z = x.union(y) - оставит только уникальные значения

v = x.difference(y) - оставит только разницу
c = x.intersection(y) - оставит только пересечение

# Объявление кортежа
z = ('a',) - необходимо объявлять с запятой на конце иначе интерпретатор будет думать, что в скобках объявляем переменную

# Объявление функции
def z(arg):
	return arg+1;

# Как показываются пустые структуры данных
l = list()
print(l)
[] - пустой список

z = dict()
print(z)
{} - пустой словарь

s = set()
print(s)
set() - пустое множество
s = {1, 2, 3} - заполненое множество
#т.к. пустой словарь изображается с фигурными скобками, то множество изображается через конструкциюю set() 

c = tuple()
print(c)
() - пустой кортеж


#Аннотации в функции
def x(word:str)-> set:  
    vowels = set('aeiou')    return print(vowels.intersection(set(word)))

:str - показывает, что у нас аргумент ожидается типа строка
-> set - показывает, что возвращаемое значение типа множество

# Знавчение по умолчанию в аргументе
def x(word:str = 'xxx')-> set: 
значение по умолчанию будет использоваться везде, где мы не передали аргумент

# Описание работы функции
def x(word):
    '''Описание работы функции'''
    vowels = set('aeiou')
    return print(vowels.intersection(set(word)))

help(x) - возвращает строковый комментарий функции, возвращает тип принимаемого аргумента и возвращаемое значение

# Присваивание аргументов
Допустим имеется функция
def x(word:str, letter:str)-> set:  

По умолчанию аргументы в нее передаются:
x('abba', 'b')

Но мы можем передавать аргументы и так:
x(letter = 'b', word = 'abba')

Это удобно в функциях с большим количеством аргументов.


# Создание модуля
Модуль - это любой сохраненный файл содержащий функцию. Однако интерпретатор полагает, что модуль находится в пути поиска.
Интерпретатор ищет модули в 3 местах:
- текущий рабочий каталог (папка которую интерпретатор считает текущей);
- каталоги хранилища сторонних пакетов (модули которые мы установили или написали сами);
- каталоги стандартной библиотеки Python;
```

# Особенности значений переменных
Как я понял в Python также используется ссылочный тип данных аналогичный JS.

# Пакеты
[48-50 видео](https://www.youtube.com/watch?v=hWsBYrASuqU&ab_channel=selfedu)
Модуль - отдельный файл с кодом программы который можно импортировать в другие программы.
Пакет - специальным образом организованный подкаталог с набором модулей, как правило, решающих сходные задачи.

В баше команда:
*pip freeze > requirements.txt* - позволяет  выгрузить модули и их версии, в том случае, когда нам нужно поменять машину и потом туда подтянуть пакеты с определенной версионностью.

*pip install -r requirements.txt* - устанавливает пакеты и версии из указанного файла

_ _ init_ _ .py* - инициализатор пакета, в котором мы указываем, что импортировать   
![[Pasted image 20250720181438.png]]
В данном случае у Init.py указана абсолютная ссылка

from .python import get_python - относительная ссылка

import package_name - импортировать пакет
print(dir(courses)) - показывает пространство имен, которое находится в пакете
При импорте пакета автоматически выполняется файл(пакет который мы импортируем) и все, что в нем определенно - функции, переменные и т.д. (а также импортировано из других файлов) автоматически выполняется.
## Import могут быть на уровне модулей и на уровне отдельных переменных
### №1
![[Pasted image 20250720231343.png]]
Мы можем импортировать все пространство имен
init.py
Import courses.Python

И тогда будем отдельно обращаться к каждой функции в этом пространстве имен (Python)
## №2. Абсолютный импорт
Неудобен, т.к. указываем фиксированное название папки
![[Pasted image 20250720231706.png]]
А можем импортировать функцию из пространства имен
init.py
from courses.Python import get_Python

courses.get_python()
При таком импорте функция get_python добавляется сразу в пространство имен пакета.

## №3 Относительный импорт единичный
Более безопасный вариант импорта
![[Pasted image 20250720231950.png]]
from .имя_папки import имя_модуля- относительная ссылка

## №3а Относительный импорт множественный
from . import имя_модуля1, имя_модуля2, имя_модуля3 - относительный множественный импорт