# Otus 
Зачем ее делать?
1. ПОзволяет более точно оценить задачу и проект.
2. Оценить реалистичность и технические риски (дьявол в деталях).
3. Спланировать работы, определить зависимости (диаграммы ганта и зависимости в джире).
4. Приоритизация задач.
5. Распределить ответственность за выполнение (коллективная безответственность снижается). СДелать прозрачным контроль.
6. Обоснование бизнесу когда и что будет готово.
7. Хорошая удачная декомпозиция позволяет делать маневры по ходу выполнения (например прилетает задача вне очереди).
8. Упрощается процесс тестирования.

## Структура работ VS Структура продукта

Содержание продукта (структура продукта) - свойства и функции, которые характеризуют продукт, услугу или результат.

Содержание проекта (структура работ) - работы которые необходимо выполнить, чтобы получить продукт, услугу или результат с заданными свойствами и функциями. Термин содержание проекта включает иногда в себя содержание продукта.

Мы решаем обратную задачу - от результата. Т.е. нет образа результата - нет декомпозиции задач. 

Пример - дом и из каких блоков он состоит. Это структура продукта. А структура работ, это как мы получим эти блоки. 

Прежде чем декомпозировать задачу нужно разобраться с тем, чего мы желаем получить в результате. Это отчасти про требование, отчасти про решения которые мы выберем.

Необходимо нормально выявить проблемы/возможности. Собрать к ним требования и составить функциональность которую мы будем делать. Чем ближе подходим к решению сложной задачи, тем лучше начинаем ее понимать.

Пример как с загрузкой вебстраницы - когда мы загружаем ее при плохом интернете, в начале появляется нечеткий шаблон, чье качество при загрузке увеличивается, так и с задачей. Лишь ближе к концу мы начинаем понимать все цели задачи.

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXe-p79hbJIsTpYnRBSwiBcMkc_6Q_l2w6lWwuTB7JQZsFo5_xaJcWmqYA7J3STu67EPr1BJRPoUtGgn1ueGP0kX0WZm2M2py5-tOIjzNtmxil-9JG0Sp5c9yVzePEEOOVg0vgYhEBes6Ytx25SCq_NQAxEk?key=EKZ300G7pSYst9zvKncWdQ)

Если мы находим находимся на одном из этапов техзадания, то скорее всего мы как при загрузке вебстраницы, видим лишь приблизительный шаблон окончания задачи.

По мере уточнения требований появляется архитектурная постановка и реализация. На этапе технического решения появляется шанс сделать нормальную структуру продукта. 

Переход на разработку осуществляется на стыке Реализации/Разработки.

Общая схема уровней декомпозиции

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXczDxf7mRK6DrthlmU4IgIFZUpOCA375CFts1wS4ttsnOwvaHwelTGLJe_sHI2xPwHu2Qhq6f4Xzj1cn27Z8g4sITBZQN6wGrbFZpXyYWdwAOKIm2COGnwTliAvz_VqmT3SJAmwbmHPNJU43dZ9lZ-TGYs?key=EKZ300G7pSYst9zvKncWdQ)

На пред предыдущий слайд: 
- тех. задание - проект
- тех. проекта - эпик, стори
- рабочий проект - сабтаски

Кто заинтересован в декомпозиции:
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeFbqqGVUVygn4Wiz-Y_tuquKQtu8hcuUHLsiiszxzkVALd7q9X2PZiOm7ZKy0oCkOoOdFGboGNO6IRiwNuuDNT_BsE_gBZMsi-KQcesOYpg4rQUTTwdhJXUEiprej5cqHQ4-bFZIE6mAdS1keMw2RQS847?key=EKZ300G7pSYst9zvKncWdQ)

3 треугольника:
- верхнеуровневый - заказчик менеджер аналитик (техзадание);
- менеджер аналитик тимлид (стори эпик);
- аналитик тимлид команда;
    
Смотрим на общую схему декомпозиции - если мы нормально отработали подзадачи, и столкнулись с проблемой, то мы начинаем понимать где верхнеуровнево мы проседаем.

### Способы декомпозиции задач
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeomOtkn6JKCEyB1Fg-QkoBHgooIjR8pF8kzCUUzkc2cR8lUbrzd2C1LnH7tFCMXfy9ufv2KXtgTaO3g2k3a_m3hKcN5jais-2K4Vl1IJx96rwYlOmQiHWL10s-PkYgr_GuHgXFahGaijX9EQPQU681FzU?key=EKZ300G7pSYst9zvKncWdQ)

Слева стандартный уровень декомпозиции. Когда каждую задачу мы решаем в каждой подсистеме.

Справа - декомпозиция на уровне подсабтасков, еще более измельченно.

СЛева - вертикальный подход, справа горизонтальный.

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeG6VsQOIam5n8JOgirZ890JY_6mtDgfRueHURMmiTcMhehEVZJ95U8LpY_JF0wYE6aZZN5MpgcIFu-hIpmtZlpKwXQRFAf-AMkJmx8BrxPdXQGA3XFcYJVx5xoX7A4TzwmbTGNbyD0VFW5NcKWkPRG2Ed4?key=EKZ300G7pSYst9zvKncWdQ)
Проектирование и архитектура, внедрение и настройка больше склонны к горизонтальной декомпозиции, когда накоплен определенный бэк задач.

Минусы горизонтальной декомпозиции: на выходе не получаем работающий результат. Необходимо ждать другие части (бэк, бд и т.д. в зависимости от того, что у нас готово).

Минусы вертикальной декомпозиции:
- разделение на задачи требует больше времени;
- вертикальная декомпозиция состоит из горизонтальных задач;
- сложно разделить работу нескольких разрабов;
- большой срок выполнения тасков до конечного результата;
### 11 вариантов декомпозиции
1. Разделение по потребностям пользователя (логика MVP, какие потребности мы хотим закрыть в первую очередь, итерационно)
2. Разделение по этапам бизнес-процесса (оцифровываем необходимый нам БП, определяем, что элементы внутри продукта - разные этапы процесса. ПРием заявок, распределение заявок, отправка заявок и т.д.). ПОдробно описывается по ссылке на 16 странице.
3. Разделение по ключевым ролям (учитель отдельно, ученик отдельно). Сам вариант подходит для горизонтальной декомпозиции. Желательно делать таски продолжительностью не больше 8 часов, иначе из-за особенностей восприятия они становятся неэффективными.
4. Разделение на основе позитивных и негативных сценариев (отдельная функциональность с негативными сценариями - восстановление пароля и т.д. Определяем какие негативные сценарии в первую очередь делаем)
5. Разделение по объектам и операции CRUD (create, read, update, delete - идем не от процессов, а от ролей. Построение логической модели, которая позволяет определить ключевые сущности в предметной области и отыгрываем от них. Например есть транспортная накладная, должен быть UC который позволяет эту накладную создать, изменить, удалить и т.д. Дальше начинаются вариации как это можно сделать. Но первичным объектом является сущность над которой мы начинаем работать.)
6. Разделение на основе бизнес-правил (изменилось законодательство)
7. Варианты интерфейса (например разные языки, многонациональный продукт)
8. Способ реализации (веб-версия или моб. приложение)
9. Разделение от команд и компетенций (даем задачи в зависимости от специфики команды, например BI команда получает задачи по BI)
10. Декомпозиция по SMART. (Хотя я думаю, что смарт это методология. При помощи смарта можно использовать приемы описанные выше). 
11. Желательно визуализировать декомпозицию, чтобы понимать как достичь цели.
  

### Мой вариант:

0. Описать As is/to be.
1.       В рамках бп мы определяемся с местом которое будем автоматизировать.
2.       Определяемся мы смотрим на этот процесс со стороны процесса или со стороны объекта.
3.   CRUD.
4.       Все ли позитивные и негативные сценарии мы предусмотрели.
5.   SMART.

Лучше пробовать разные способы и сочетать их.
Как вариант вначале делаем процессную или объектную декомпозицию. (Что можно сделать с объектами, как идет процесс?) А потом можем сделать позитивные и негативные сценарии, получится двухуровневая структура, все это дело можно комбинировать. И уже на основе этого дела разрабатываются таски
# Декомпозиция системы с точки зрения архитектуры
[https://analystdays.ru/ru/talk/71851](https://analystdays.ru/ru/talk/71851) - взято отсюда
[https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf](https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf) - обязательно к прочтению на английском
Декомпозиция подсистемы - разделение системы на составные части в каждой у которой есть четко определенная функция, роль.

Стандартное поведение при декомпозиции:
Стадия 0 - предпроект/концептуальное проектирование
Стадия 1… n - анализ и проектирование, разработка , внедрение и т.д…
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXe4d1lkauEm0spOEThxFzfN92_mj09YxGpoKY8WVxYI9-SIWWJUPZqVhhIYlCx39nMw0UD8HLEAZE1Q5jTz7nLmtBSluYCbLTbWbvtT5wnAw-Cu3oxkjWBOOAh2WNw4ohIR2J4m4p1zhiMYwU3TeGRjuTM?key=EKZ300G7pSYst9zvKncWdQ)
Если первичная декомпозиция сделана плохо, то бывает уже поздно.
ПРоцесс создания подсистем:
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfNfT9kR0S8y74UAmbFOA7xJ_H2bw6DScHeAKvwKgbAQv1DNM_F92elC0GJp535RtTXWvPoCOblCn3lfDfLrqF_89vTTw1IsifxNsvvE9tECBdcuBV7wMXDxaZa6BJIPCOBGzuU3rewcQ1IyF9d8ZOh6iJs?key=EKZ300G7pSYst9zvKncWdQ)
Подобная декомпозиция может быть плохой. 
У декомпозиции системы должны быть свои критерии. Зачем при декомпозиции разбивать систему на модули? Какие есть критерии этого?
Критерии хорошей декомпозиции:
- управляемость(независимые команды). На каждую систему назначаем отдельную команду которая занимается ее разработкой, мы понимаем какая команда за что отвечает;
- гибкость продукта(внесение изменений). Если система декомпозирована так, что подсистема может разрабатываться отдельно от других систем, то ими можно управлять еще более гибко;
- Усвояемость. Изучение системы по частям;
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfDYpjvAC2JfdxznLki2jA7_euw3S2O-m3UDen_v3HxljYVxe6AWyWtrOQRq6XzNw4xNje05fcyGrgrGl_DrFHjSJD0KHb7el24EQ-zMgowvyoJUNk0VCES-4G1dey3BruXA2SJ_uTFlSc9yq-vJNBeamtg?key=EKZ300G7pSYst9zvKncWdQ)
Например с точки зрения функциональной декомпозиции подсистема обработки и интеграции абсолютно не самостоятельны, их нельзя рассматривать отдельно. ПОэтому в реальности не существует этих двух подсистем, они не отвечают критериям декомпозиции(нельзя разрабатывать подсистему хранения данных отдельно от подсистемы обработки, они взаимозависимы - изменения в одной неизбежно влияют на изменения в другой, изучение подсистемы по частям не получится). 

ПРавильные подходы к декомпозиции:
- алгоритмическая декомпозиция систем;
- объектно-ориентированная декомпозиция систем;

Емко описаны в книге - объектно ориентированный анализ и проектирование с примерами приложений

## Алгоритмическая декомпозиция
- разделение вдоль процесса функционирования алгоритма (процесса);
- переиспользование шагов процесса/подпроцесса. ПРоцесс-подпроцесс выделяется в подсистему и их пытаются использовать на протяжении всей работы системы;

Примеры:
- системы документооборота (как правило система строится вокруг процесса);
- системы потоковой обработки данных;
- системы аналитики;
- function-as-a-service;

Системы безсервисной архитектуры - какое-то новое веяние
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeQCwe2T5GppaL1NShsZO9maObxxN8IAZER012tkS3wYk0KnQYbWIDy1L5tw21ZZWQIeY_V0wwcyPdd6znpYJ8I8oVNl1N6bzP4SjQ8gzLsh7FIJy1xju-uAN5EyJcypVLaBoWayrkwo6i4Z-rCQVH4sZOf?key=EKZ300G7pSYst9zvKncWdQ)
На приведенной выше картинке система соответствует всем трем критериям.
Ключевое правило любой подсистемы - интерфейс сохраняем, реализацию меняем.
Самый простой способ при алгоритмической композиции разделить систему на подсистемы - пройти вдоль ее алгоритма.
Но есть одна проблема - если сломается подсистема валидатор, все остальные подсистемы перестают работать.
Для того, чтобы понять как работают алгоритмические декомпозиции необходимо изучить:
- принципы работы распределенных систем асинхронный сх;
- паттерн pipe and filters;
- для самых технически подкованных - streaming architecture;

  Обращать внимание:
- доступность - требование к отклику и времени выполнения процессов;
- горизонтальное масштабирование - требование которое ограничивает масштабируемость (ведет к statefull подсистемам);
  
Объектно-ориентированная декомпозиция - начала использоваться в 21 веке.
Отличие от алгоритмической декомпозиции - переиспользование не шагов и подшагов процесса, а переиспользование абстракций и их поведения. Процессы заложены, но в основе своей концентрируются вокруг объектов.

ООД это: 
- объект системы представляет собой некую абстракцию;
- разделение системы на основе принадлежности ее элементов к абстракциям предметной области и концентрации вокруг них;
- переиспользование абстракция и их поведения;

Пример:
- системы-реестры;
- системы бэк-фоиса предприятия;
- классические микросервисы;
ПРимер ООД

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXc2FpEU533bUq5AV4a8kP_rJzOpIGlOStqob9g2rjLnLThW79gPokOdPBTPWLDJqjkwEqIGF5ASYBqq0RQR5qmeu4hAosK77hr0O-UseiyjByHx7KCyxa0w63d-8lze-YN9N-GqEXgZrtZwf0FOjn1WeuWa?key=EKZ300G7pSYst9zvKncWdQ)

Управление клиентами, заказами, доставкой отдельно. Все 3 процесса отдельно. Если отвалится один процесс управления, то 2 других будут продолжать работать в отличии от АД.

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXdgyAyLg8GxtmTiVef4eMykUjHnYiGQICzfpT2aaLeWQenSoHx0cY5SQtMw0A2pPnXkCzQVQA_tfbnM2yoEGD7IVdKJb8fNW4Xp430tXdh2vG3vo9_aDwGFXObq7rDeYPP-SSHyoQtAsONBZckL2Xr4INkl?key=EKZ300G7pSYst9zvKncWdQ)

Такие архитектуры задумываются для полного распараллеливания процессов эксплуатации. Однако методы реализации могут хромать.

Проблема у ООД с требованием усвояемости:
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfGp8XLstTgJY-mE3mSNycLoZRWVvxU_05lWyQKqRFcjq5oMkst2g7ufUU3B27izwqicRBCHhDoTnj755VWm1LwceE0wn9ZJzsmmX38gg_emo_H6S4M4cwaWLzfx-H0yYH_ZvmnNoiBwCUGUUQpOLcSIoQ?key=EKZ300G7pSYst9zvKncWdQ)

Даже выясним как работает каждый микросервис отдельно мы не понимаем весь процесс целиком.

Для ООД:
- domain-driven design;
- принципы работы распределенных систем;

В ООД необходимо обращать внимание на:
- концептуальную целостность;
- организационные границы (зоны ответственности бизнеса, разработки и т.д.);

По итогу при декомпозиции системы необходимо выбрать один из двух подходов. МОжно комбинировать, но одна должна быть основной.
Независимо от выбранного подхода необходимо придерживаться некоторых принципов декомпозиции:
- принципы высокой сцепленности и слабой связанности(Один из самых важных принципов, его надо отдельно гуглить);
- учет границ (бизнеса, организации-пользователя, организации-разработчика, технических процессов);
- сохранение концептуальной целостности (решение решает проблему, концепции системы согласованы друг с другом, все части системы реализуют одну идею);
  

## Антипаттерны декомпозиции:
- подсистема - инфраструктурный элемент (например подсистема хранения данных. БД это только БД, но никак не подсистема);
- подсистема-бог или супер-подсистема (подсистема обработки(как правило в этом элементе сосредоточены интересы многих людей, организаций, смежных систем, глохнет эта система, глохнет все), подсистема бизнес-логики);
- ничего кроме data-flow-подсистем;

Итого нас интересуют: 
- критерии хорошей декомпозиции;
- два варианта декомпозиции с их комбинированием;
- общие принципы и анти-паттерны;
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXdM8REZ-tBLb4qhs9uZE78_DJRdIZQ5EC5HaABlD8wJBRYatCBbUuXsOdcJb6xwaRBqc0gfRjVQpPz3Bv_AUhYLSdAjh4Z0y6PtZQXkUL-MWvOZdAPZ_oX3_kTr7NiXAbOTNRQW8LZYsXT5va9ClmeXdTQ5?key=EKZ300G7pSYst9zvKncWdQ)

# Декомпозиция по яндексу
Можно не декомпозировать задачу, если инструкция помещается на лист а5. Решение задачи ограничивается 2-5 пунктами. Во всех остальных случаях надо декомпозировать

Декомпозировать можно двумя путями - упрощать задачу и упрощать интерфейс.

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXfgx3YYOIMuu67p9d5t1cghjNLr4WRKC_nxAtqzh8bKIzoJy-Jsg3hAqnyYJ_BU40YZmEs1-qPr86oxaif5lvcKtRBcpcB0_op7I_j70sfl9SGNOJOxscTuC0hbhbiumFAjfAmLt6XsGiD9ZLwu1HAbq-g9?key=EKZ300G7pSYst9zvKncWdQ)

Проблема:
задание не большое, но инструкция большая;
много особенностей в инструкции для разных данных;
высокая вероятность ошибки;

Решение:
ищем признак по которому можно выделить группы данных и создаем отдельную задачу или подзадачу под эту группу. Как правило группировка этих данных в реальности происходит через автоматизацию. То есть задача будет выглядеть следующим образом, что если у входных данных есть какой-либо признак, то отсеивать его в ту или иную сторону.

## Упрощение через интерфейс
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXdJOrkC4fXX_TNMKzvCc5CvUA7JzqU5VWbwKwRnkMXIHv5IrHIieW3frQy3gCsawiRy7P3SPRqOD03Jxp-QOU2o0mj2BOApJs7C6yDUVW8zCVup66o0lkzSUKB2DEEqLheQjmQ2VK_t36tIFEzBV7uLhAiJ?key=EKZ300G7pSYst9zvKncWdQ)
Проблема:
мы показываем пользователю больше, чем нужно в моменте;  
внимание исполнителя рассеивается даже внутри небольшой задачи;
все еще есть вероятность ошибки;
Решение:
исполнитель последовательно выполняет задачу, фокусируясь на том, что нужно в конкретный момент.

![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeuETVJyiCuPmxfPVHXvcLHeiSmaeQk1Ejd7cvoxCZuWJjK6UOkyxYYftDr9TttlUtGV_3ubsVdE7TZsVw40dmW6K15-QBxuxW0MOrqvTyiJSO7t9FbToWTEDgQ6aPAQiXArmkK-LgzX1W5YnsoWb0YJ99n?key=EKZ300G7pSYst9zvKncWdQ)
Проблема:
-  даже в простом задании пользователю нужно разобраться и понять, что от него хотят;
- если исполнитель думает, он ошибается особенно на большом масштабе;
- ошибка все еще возможна;

Решение:
- формулируем задание (вопросы) правильно, сводя вероятность ошибки к минимуму;
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXeDfVh1MUJiu2iBbhNCKYQXOCErfhpbyTD2nbBPA4ClnUs1-Qki0oKs3Rq2wZQDKSQKY2eL1SIGtfdYhL5Hz38jorx-c48JWlwL4AkDM82kEVq5j5e_IjS9nLubeXBZZeE7nEemTVkQ4Gu023gbPid283y2?key=EKZ300G7pSYst9zvKncWdQ)

Проблема: на задании невозможно сделать настроить контроль перекрытием, ханипотами.

Решение - делаем отложенную приемку, а задания которые выполняют приемку уже поддаются контролю и всем способам декомпозиции.

# Декомпозиция digital-проектов: откуда это на странице?
[https://www.youtube.com/watch?v=Y4x65IbVgpE&list=PLZDOrDrtQpIks22_LRbsrk2mxBKp8ls1B&index=9&ab_channel=VladimirZavertaylov](https://www.youtube.com/watch?v=Y4x65IbVgpE&list=PLZDOrDrtQpIks22_LRbsrk2mxBKp8ls1B&index=9&ab_channel=VladimirZavertaylov)

В целом в видео описывается декомпозиция всех процессов жизни сайта. Расписываются все процессы необходимые для самодостаточной жизни сайта. Как со стороны пользователя на сайте, администратора, сотрудника. Работа БД и так далее, на различных уровнях абстракции в контексте тех пунктов которые перечислены у ОТУСа.

  
Как нам понять, что мы все учли при декомпозиции?
Для того, чтобы это проверить мы все учли мы используем сценарии использования - Use Case. 
В данном случае это будет пример некорректной-неполной декомпозиции т.к. сложно оценить что мы не учли. В таком случае лучше все это дело также отрисовывать экранами - вспомнить пример с дизайнами в ЛКП.
СЛедующий вопрос связанный с экранами - откуда этот элемент появился на экране и при каком событии.

Как правило эти вещи лучше документировать и давать описание. КОгда нет понимания при каком событии появился элемент, необходимо идти и пытать заказчика.

# Декомпозиция от спортмастера
Необходимо четко обозначать границы при которых задача считается выполненной:
- Задачи должны быть логически завершенные, они не должны зависеть от других задач.
- Задача обязательно должна нести бизнес смысл.
- Задачи должны быть небольшого размера, в излишнюю детализацию погружаться также не стоит иначе придется тратить много времени на управление задачами.
 
Когда используем юзер стори для декомпозиции делаем разделение по задачам по союзам И/ИЛИ:
- Как пользователь я хочу сделать заказ И оплатить его картой ИЛИ бонусами;

По итогу три задачи:
- сделать заказ;
- оплатить картой;
- оплатить бонусами;

При использовании UseCase мы имеем один основной путь и несколько альтернативных вариантов:
![](https://lh7-us.googleusercontent.com/docsz/AD_4nXflvqZxx-48k2TDJ6Ook8jZRubOF4AJVi4lSC6BWoC5Y0Tigc05MGmINwagyTKGiNgoaoXHkx1wfV1NHgxEXBSj11GEJF-GJznRPp22vilf9LkcH-nRtDHRpro4aeGqO3Pm0llS2UJd4MR8YGggvl1ZV1wm?key=EKZ300G7pSYst9zvKncWdQ)

Двигаемся от простого к сложному - делаем простой функционал который приносит какую-либо ценность. Затем данный функционал обрастает дополнительной функциональностью.

Баннер - Картинка - Карусель из картинок - Редактирование картинок и т.д..

Разделить на операции CRUD - используем когда чем-то нужно управлять или конфигурировать

Разделение по ролям - когда функциональность подразумевает работу нескольких ролей и групп пользователей:

- Анонимный;
- Авторизованный;
- Админ;

Обработка ошибок - необходимо выносить в отдельные задачи. Используют когда необходимо получить быструю обратную связь выводить ли данную функциональность.

Сначала статически, потом динамические - если можно реализовать работу функционала на статических данных/заглушках, а потом подставлять динамические данные при помощи интеграции систем.

Производительность - когда нужно, чтобы это работало, затем ускорить. Не самый хороший, но используемый способ декомпозиции.