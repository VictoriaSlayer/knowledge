{
	"nodes":[
		{"id":"90e40f73d415dd3c","type":"text","text":"Файловый обмен\n","x":-764,"y":-197,"width":250,"height":60},
		{"id":"2552249bb063f21f","type":"text","text":"Облако","x":-600,"y":80,"width":250,"height":60},
		{"id":"fad5b597d3025508","type":"text","text":"Сетевая файловая система","x":-960,"y":80,"width":250,"height":60},
		{"id":"bb379cb2efc0be82","type":"text","text":"Условия:\n1. Протокол взаимодействия;\n2. Настройки подключения к серверу (путь, учетные записи для подключения);\n3. Условия запуска обмена (событие триггер или расписание);\n4. Формат и объем передаваемых файлов.\n5. Схема передаваемых данных.\n6. Порядок удаления файлов с сервера.\n7. Логирование событий.\n8. Правила валидации файлов.\n9. Правила обработки ошибок.","x":-1089,"y":215,"width":739,"height":505},
		{"id":"f8942032421c0b5a","type":"text","text":"DWH","x":-174,"y":74,"width":250,"height":60},
		{"id":"a530a5a9ed0598a9","type":"text","text":"Data Lake","x":109,"y":73,"width":250,"height":60},
		{"id":"6e64bbaf0849e1d9","type":"text","text":"Частная БД","x":460,"y":73,"width":250,"height":60},
		{"id":"b9fc5bee4bd1ab58","type":"text","text":"Базы данных\n","x":109,"y":-192,"width":250,"height":50},
		{"id":"bb751afa9b1aa2de","type":"text","text":"Условия:","x":-174,"y":215,"width":884,"height":56},
		{"id":"1073a11fa2fd6f81","type":"text","text":"Тип подключения:\n- напрямую из приложения;\n- Через DBC (database connectivity);\n![[Pasted image 20250113194405.png]]","x":-174,"y":340,"width":884,"height":940},
		{"id":"1a828a60c1b52129","type":"text","text":"Алгоритм:\n- создать схему данных;\n- создать представления;\n- создать роль и пользователя;\n- выдать права;","x":-174,"y":1320,"width":884,"height":221},
		{"id":"d5cadaf2953f5869","type":"text","text":"Определяем условия:\n- нативное подключение или через DBC API;\n- объекты БД для обращения;\n- роль для доступа;\n- предотвращение опасных операций (удаление или запись);\n- предотвращение от встраивания в запрос вредоносного кода;","x":-174,"y":1580,"width":884,"height":300},
		{"id":"130a9079662dac5b","type":"text","text":"*SOAP*","x":920,"y":322,"width":250,"height":60},
		{"id":"53366ee59a953093","type":"text","text":"Для каждого типа API свои условия и это отдельная тема, тезисно выписал основное. А так, то можно полезть в статью почитать условия.","x":920,"y":450,"width":6160,"height":50},
		{"id":"6d09b79ffc81ca3e","type":"text","text":"1. **Перечень функций** на сервере и их названия нужно закрепить в WSDL-схеме.\n2. **Структуру и содержимое XML-сообщений** **запросов**, включая типы данных, нужно закрепить в XSD-схеме, которая будет использоваться для валидации запросов.\n3. **Методы аутентификации клиента**. Будет ли это базовая аутентификация или с использованием токена? Параметры для аутентификации передаются в заголовке запроса.\n4. **Перечень статусов ответов сервера**, в том числе для ошибок. Статусы ответов передаются в заголовке ответа.\n5. **Структуру и содержимое XML-сообщений** **ответов**, включая типы данных, нужно закрепить в XSD-схеме, которая будет использоваться для валидации ответов.\n\nКогда использовать SOAP:\n- надёжность и безопасность важнее скорости;\n- строгие контракты важнее высокой частоты изменений;\n- логика удаленных процедур сложна;\n- нужны транзакционные операции.","x":920,"y":547,"width":840,"height":773},
		{"id":"a30251f7df7e721e","type":"text","text":"*REST*","x":1865,"y":323,"width":250,"height":60},
		{"id":"88a14d9d45d9013c","type":"text","text":"Условия использования:\n- Набор конечных точек: маршрутов и HTTP-запросов к ним. Часто конечные точки еще называют эндпоинтами (endpoint) или «ручками»;\n- Формат, структуру и содержимое полезной нагрузки запроса для каждой конечной точки;\n- Аутентификация клиента для каждой конечной точки;\n- Статусы ответа сервера для каждой конечной точки;\n- Формат, структура и содержимое полезной нагрузки ответа для каждой конечной точки;\n- Для документирования REST API принято использовать спецификацию OpenAPI;\n\nREST хорошо подходит для интеграции ИС, когда:\n- нужно сделать быстро и просто;\n- скорость важнее надёжности и безопасности;\n- нужно часто вносить изменения в контракты взаимодействия;\n- бизнес-логика не очень сложная и операции над бизнес-сущностями ограничены набором CRUD-операций (Create, Read, Update, Delete);\n- экономия трафика не важна;\n","x":1865,"y":547,"width":947,"height":773},
		{"id":"48dbdf3d80481d51","type":"text","text":"**GraphQL** ー технология на основе REST для обработки запросов к приложению с помощью API. GraphQL как технология объединяет в себе язык запросов, среду обработки запросов и архитектуру клиент-серверного взаимодействия.\nГрубо говоря GraphQL соединяется через прокси-сервер с приложением.\n![[Pasted image 20250113202230.png]]\nУсловия:\n- Набор конечных точек ー маршрутов и HTTP-вызовов к ним. Чаще всего в GraphQ только одна конечная точка ー точка входа в приложение, а все необходимые действия описываются уже в теле запроса. При этом GraphQL позволяет реализовать и несколько конечных точек;\n- Для каждой конечной точки ー вид запроса (запрос, мутация, подписка на события) и JSON-схема полезной нагрузки запроса клиента;\n- Для каждой конечной точки ー методы аутентификации клиента (будет в заголовке запроса);\n- Для каждой конечной точки ー статусы ответа сервера, в том числе для ошибок (будет в заголовке ответа);\n  \n  GraphQL хорошо подходит для интеграции ИС, когда:\n- нужно собирать данные из разных источников;\n- нужно сократить число запросов от клиента к серверу, передав в ответ только те данные, что запрашивает клиент;\n- в OLTP-системе (транзакционные системы) нужно добавить аналитику (OLAP-запросы) без денормализации базы данных или реализации витрины/отдельной системы и т.д.;","x":2935,"y":547,"width":947,"height":1093},
		{"id":"b8efbf2d18d8f34a","type":"text","text":"*gRPC* - фреймворк реализации RPC","x":3980,"y":323,"width":700,"height":60},
		{"id":"6f62adbde03eae65","type":"text","text":"*GraphQL*","x":2935,"y":323,"width":250,"height":60},
		{"id":"810fe3e5da5c1307","type":"text","text":"Основа:\nhttps://habr.com/ru/articles/841862/\nhttps://habr.com/ru/articles/849852/","x":-764,"y":-1080,"width":588,"height":93},
		{"id":"88427745732571e9","type":"text","text":"[[2. Конвейеры данных. Современная инфраструктура данных]]","x":101,"y":-1080,"width":484,"height":93},
		{"id":"5140a54833d839c0","type":"text","text":"Актуальные технические виды интеграций","x":3748,"y":-715,"width":465,"height":60},
		{"id":"4c1e84b94ae24b6d","type":"text","text":"API/RPC - remote procedure call","x":3763,"y":-200,"width":450,"height":50},
		{"id":"0e8c97f3ed0a1e06","type":"text","text":"*Webhook*","x":5060,"y":323,"width":700,"height":60},
		{"id":"08da2c5cc527743a","type":"text","text":" Вебхук ー это HTTP-запрос, только сформированный и отправленный автоматически при наступлении события.\n\n   Определить параметры при проектировании:\n1. Определить, какие данные будут передаваться, включая формат, схему и логику преобразований данных при необходимости.\n2. Определить состав событий-триггеров.\n3. Настроить механизмы аутентификации и авторизации для подтверждения подлинности запросов.\n4. Настроить вебхук в системе-источнике, указав URL системы-приёмника, на который будут отправляться запросы при наступлении события-триггера.\n5. Настроить Webhook API или реализовать приёмник вебхуков на стороне системы-приёмника для обработки входящих запросов.\n\nWebhook хорошо подходит для интеграции ИС, когда:\n- когда характер обмена событийный (не периодический);\n- когда клиент не знает, когда на сервере будут новые данные, но должен получить их, когда они появятся;\n- когда нужно избежать периодических и безрезультатных обращений клиента к серверу, например, для экономии трафика;\n- асинхронной интеграции;","x":5060,"y":547,"width":976,"height":753},
		{"id":"02acfd1459315331","type":"text","text":"*WebSocket*","x":6104,"y":323,"width":700,"height":60},
		{"id":"21c8a0024e7aa2cd","type":"text","text":"**WebSocket** ー протокол связи между клиентом и сервером. Установка websocket-соединения осуществляется с помощью handshake.  Handshake ー это приветственное сообщение (рукопожатие), которое отправляется клиентом на сервер. Оно сигнализирует, что необходимо перейти с использования протокола HTTP на протокол WebSocket.\n\n   Определить параметры при проектировании:\n1. Определить сценарии, при которых будет отправляться сообщение от клиента к серверу или наоборот.\n2. Определить передаваемые сообщения: пример данных, включая его формат и схему.\n3. Сформировать требования по безопасности, чтобы разработчик мог выбрать между wss (WebSocket Secure) и ws (WebSocket) протоколами. В публичных сетях существует риск перехвата чувствительных данных, поэтому лучше использовать wss с TLS (Transport Layer Security) для шифрования полезной нагрузки.\n\nWebsocket хорошо подходит для интеграции ИС, когда:\n- нужна интеграции в реальном времени;\n- нужна двусторонняя связь клиента с сервером;\n- нужно долговечное решение.","x":6104,"y":547,"width":976,"height":653},
		{"id":"b90bd6a05bf69852","type":"text","text":"Брокеры сообщений","x":7217,"y":-200,"width":305,"height":50},
		{"id":"04330029a124224d","type":"text","text":"**Брокер сообщений** ー архитектурный паттерн и программное обеспечение, предназначенные для реализации асинхронного взаимодействия элементов распределённой системы. \n\nБрокер сообщений реализует несколько иной подход, чем те виды интеграций, что мы рассматривали ранее. В парадигме использования брокеров сообщений понятия «Клиент» и «Сервер» отходят на второй план. Брокеры сообщений оперируют другими понятиями.\n\n1. **Отправитель** или **producer** ー подсистема или сервис, который публикует данные в брокер.\n2. **Потребитель** или **consumer** ー подсистема или сервис, который подписывается на получение сообщений из брокера и потребляет полученные данные.\n\nБрокер является посредником между отправителем и потребителем. Можно сказать, что брокер выступает сервером, а отправители и потребители ー клиентами. \nВзаимодействие между отправителем и потребителем асинхронное, то есть отправитель не знает какие потребители и в каком объёме получили из брокера данные. \n![Рис.7 ー Архитектура интеграции через брокер сообщений](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c5c/2a0/269/c5c2a02694c8ffff7d90f4651b885c55.png \"Рис.7 ー Архитектура интеграции через брокер сообщений\")\nБрокеры сообщений хорошо работают в парадигме потоковой передачи данных, когда передаётся большое количество данных маленькими порциями в постоянном режиме. \nСамые популярные брокеры сообщений ー RabbitMQ и Apache Kafka. Хотя они реализуют общий паттерн брокера сообщений, между ними довольно много различий.\n\nУсловия, которые необходимо продумать при интеграции:\n1. Как будет называться канал связи, в который будут публиковаться данные. В RabbitMQ это очередь, в Apache Kafka ー топик.\n2. Параметры полезной нагрузки сообщений от отправителя: формат, схема, максимальный размер. Максимальный размер важен, потому что для всех брокеров не рекомендуется передавать сообщение больше 1 МБ.\n3. Какова надёжность потребителя. Если потребитель ненадёжный, то стоит использовать Kafka, который сохраняет данные на диске длительное время, в отличие от RabbitMQ, который удаляет данные после доставки сообщения. \n4. Фактор репликации ー количество копий сообщения ー в кластере брокера. Это нужно для обеспечения надёжности доставки сообщений.\n5. Производительность потока данных в части публикации и потребления. \n6. Требуется ли настраивать разделы (партиции) в Kafka (разделение топика на несколько разделов) или предел очереди в RabbitMQ (максимальное количество сообщений в очередь), чтобы предотвратить переполнение очереди.\n7. Стратегия разделения в Kafka, если разделение используется; тип обменника (маршрутизатор сообщений) в RabbitMQ.\n8. Размер очереди и время жизни сообщения для RabbitMQ; максимальное время хранения сообщений для Kafka.\n9. Схема потокового обмена, на которой будут отображены все топики/очереди, отправители и потребители данных. Удобно проектировать такую схему через DFD-диаграмму. \n10. Также описать интеграцию через брокер можно с помощью спецификации стандарта AsyncAPI. Спецификация в формате yaml (похожая на Open API спецификацию) содержит состав топиков, схему аутентификации, формат данных полезной нагрузки и т.д.\n\nКогда использовать брокеры:\n- нужна асинхронная интеграция, в том числе сразу нескольких систем;\n- нужна передача данных в реальном времени или низкая задержка;\n- много данных, но размер каждого сообщения небольшой;\n- событийный характер обмена (EDA-архитектура);\n- нужны высокая производительность и масштабирование;\n- есть ресурсы на развёртывание и поддержку дополнительной инфраструктуры для брокера;","x":7217,"y":323,"width":2183,"height":1357},
		{"id":"0e4f9510de48a912","type":"file","file":"Интеграция/Dump/Pasted image 20250113205016.png","x":2701,"y":-1460,"width":400,"height":372},
		{"id":"72bfe86099261ce7","type":"text","text":"# АЛГОРИТМ ВЫБОРА ИНТЕГРАЦИИ","x":2633,"y":-1694,"width":667,"height":114,"color":"1"},
		{"id":"493b6e1da75c6bae","type":"text","text":"Вопросы для интеграции:\n- какими данными должны обмениваться системы? \n- с какой скоростью и в каком объёме системы обмениваются данными? \n- как долго и как часто системы будут обмениваться данными? \n- какие ограничения и особенности есть у интегрируемых систем? \n- сколько временных и финансовых ресурсов есть на интеграцию?","x":3300,"y":-2880,"width":917,"height":250},
		{"id":"4d35e96f61d1b08d","type":"text","text":"Проектирование интеграции\n1. Кто инициирует обмен данными? \n    1. клиент обращается к серверу;\n    2. сервер обращается к клиенту;\n    3. обмен данными двунаправленный: и клиент, и сервер могут инициировать взаимодействие.\n2. Какова периодичность передачи данных. \n3. Максимальный размер, формат и схема передаваемых данных с учётом ограничений, наложенных выбранным паттерном интеграции. \n4. Характер передачи данных: пакетная или потоковая.\n5. Максимально допустимая задержка обработки данных: нужна передача данных в реальном времени или в бизнес-процессе допустимо ожидание данных.\n6. Необходима ли транзакционность, то есть нужно ли откатывать изменения, если на каком-то шаге возникла ошибка.\n7. Надёжность системы-приемника и сети.\n8. Пропускная способность системы-источника, системы-приёмника и сети.\n9. Требования к безопасности: нужно ли шифрование данных, как осуществляется аутентификация клиента.\n10. Текущие возможности системы-источника и системы-приемника, есть ли у них какие-то API?\n11. В случае ошибок какие последствия для пользователя, что нужно автоматизировать, что обрабатывать вручную?","x":3300,"y":-2540,"width":1345,"height":620},
		{"id":"8e134dc97f172b3c","type":"text","text":"Вопросы аналитика","x":3920,"y":-3040,"width":478,"height":59},
		{"id":"349c76522f34f158","type":"text","text":"Роль тестировщика:\n- проверить, что система ведёт себя как задумывалось, не возникает документов в промежуточных состояниях, которые не видны ни на интерфейсах, ни в службе поддержки;\n- отсутствует двойная обработка данных;\n","x":5540,"y":-3040,"width":920,"height":200},
		{"id":"4aa7740696328e4c","type":"text","text":"Вопросы аналитика","x":4800,"y":-3040,"width":478,"height":59},
		{"id":"c3964133fb2b9c22","type":"text","text":"Что позволяет делать?\n1. Механика «Запрос-Ответ» (Request-Response): синхронный запрос клиента и ответ сервера.\n2. Потоковая передача потока данных с сервера на клиент при подключении клиента.\n3. Потоковая передача потока данных с клиента на сервер при подключении клиента.\n4. Двунаправленная передача потока данных с сервера на клиент и наоборот.\n\n\n   Определить параметры при проектировании:\n1. Механика обмена данными: синхронный запрос-ответ или потоковая передача данных.\n2. Название удалённой функции, которую необходимо вызывать. Это описывается в protobuf-документе.\n3. Методы аутентификации клиента.\n4. Пример protobuf-сообщения полезной нагрузки ответа сервера.\n\ngRPC хорошо подходит для интеграции ИС, когда:\n- нужны разные варианты обмена данными (по запросу сервера, по запросу клиента, потоковая передача данных и т.д.);\n- требуется реализовать высокое быстродействие в реальном времени;\n- разные технологии у интегрируемых ИС и стек может расширяться;\n- важна безопасность;","x":3980,"y":520,"width":976,"height":753}
	],
	"edges":[
		{"id":"4b7518eee55f69a0","fromNode":"90e40f73d415dd3c","fromSide":"bottom","toNode":"fad5b597d3025508","toSide":"top"},
		{"id":"730c8eea8361c18a","fromNode":"90e40f73d415dd3c","fromSide":"bottom","toNode":"2552249bb063f21f","toSide":"top"},
		{"id":"041e1f48e6723568","fromNode":"b9fc5bee4bd1ab58","fromSide":"bottom","toNode":"f8942032421c0b5a","toSide":"top"},
		{"id":"7ee1a48cbd5ebace","fromNode":"b9fc5bee4bd1ab58","fromSide":"bottom","toNode":"a530a5a9ed0598a9","toSide":"top"},
		{"id":"e2071cd13d9a6077","fromNode":"b9fc5bee4bd1ab58","fromSide":"bottom","toNode":"6e64bbaf0849e1d9","toSide":"top"},
		{"id":"439937b932ca4bf0","fromNode":"bb751afa9b1aa2de","fromSide":"bottom","toNode":"1073a11fa2fd6f81","toSide":"top"},
		{"id":"cff90227f0450178","fromNode":"4c1e84b94ae24b6d","fromSide":"bottom","toNode":"130a9079662dac5b","toSide":"top"},
		{"id":"d8282eaecade96af","fromNode":"4c1e84b94ae24b6d","fromSide":"bottom","toNode":"a30251f7df7e721e","toSide":"top"},
		{"id":"8b6a834e5dd1e37e","fromNode":"4c1e84b94ae24b6d","fromSide":"bottom","toNode":"6f62adbde03eae65","toSide":"top"},
		{"id":"3a6d6b4289263ca8","fromNode":"4c1e84b94ae24b6d","fromSide":"bottom","toNode":"b8efbf2d18d8f34a","toSide":"top"},
		{"id":"84b91d3c3c139dd5","fromNode":"5140a54833d839c0","fromSide":"bottom","toNode":"90e40f73d415dd3c","toSide":"top"},
		{"id":"01ce3aa71af767e8","fromNode":"5140a54833d839c0","fromSide":"bottom","toNode":"b9fc5bee4bd1ab58","toSide":"top"},
		{"id":"995799d534b03232","fromNode":"5140a54833d839c0","fromSide":"bottom","toNode":"4c1e84b94ae24b6d","toSide":"top"},
		{"id":"44f4d43e0e3591e1","fromNode":"4c1e84b94ae24b6d","fromSide":"bottom","toNode":"0e8c97f3ed0a1e06","toSide":"top"},
		{"id":"bddee094637a2555","fromNode":"4c1e84b94ae24b6d","fromSide":"bottom","toNode":"02acfd1459315331","toSide":"top"},
		{"id":"212d986fdb49fad1","fromNode":"5140a54833d839c0","fromSide":"bottom","toNode":"b90bd6a05bf69852","toSide":"top"},
		{"id":"013e2a1e688a8160","fromNode":"493b6e1da75c6bae","fromSide":"bottom","toNode":"4d35e96f61d1b08d","toSide":"top"},
		{"id":"987925507b21c91d","fromNode":"4d35e96f61d1b08d","fromSide":"bottom","toNode":"72bfe86099261ce7","toSide":"top"},
		{"id":"b74edf61e7a45c5e","fromNode":"72bfe86099261ce7","fromSide":"bottom","toNode":"0e4f9510de48a912","toSide":"top"}
	]
}